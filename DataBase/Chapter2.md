# 관계형 데이터베이스

## 데이터 모델

물리적 혹은 추상적으로 존재하는 현실세계를 단순화 하고 정형화된 형태로 표현하는 하나의 방식 또는 규범

실제 데이터가 갖는 특성을 살리면서, 목적에 맞게 관심있는 정보만을 단순화 하여 표현하는 방식이다.

## 릴레이션의 개념

관계형 데이터 모델 : 테이블 형식을 이용하여 데이터들을 정의하고 설명한 모델, 실세계의 데이터를 누구나 직관적으로 이해할 수 잇는 형태로 기술할 수 있는 간단한 방식을 제공, 테이블을 릴레이션이라 부름

릴레이션 : 수학적으로, 두 개 이상의 집합으로부터 각 집합을 구성하는 원소들의 순서쌍에 대한 집합을 의미

속성 - 필드, 컬럼 = 값 : 릴레이션을 구성하는 각 열의 이름
튜블 - 레코드, 행 : 릴레이션의 각 행

도메인 : 각 필드에 입력 가능한 값들의 범위, 즉 각 필드가 가질 수 있는 모든 값들의 집합, 원자값 이어야 함

NULL : 특정 필드에 대한 값을 알지 못하거나 아직 정해지지 않아 입력하지 못한 경우의 필드의 값으로 0이나 공백 문자와는 다르다.

## 테이블 스키마와 테이블 인스턴스

테이블 스키마 : 테이블 정의에 따라 만들어진 데이터 구조

차수 = 애트리뷰트의 개수 : 테이블 스키마에 정의된 필드의 수

테이블 인스턴스 : 테이블 스키마에 현실 세계의 데이터를 레코드로 저장한 형태, 스키마는 한번 정의하면 거의 변함없지만 인스턴스는 수시로 바뀔 수 있음 - 레코드의 삽입, 삭제, 수정 등

기수 : 테이블 인스턴스 레코드의 수

## 테이블의 특성

중복된 레코드가 존재하지 않음 - 테이블 인스턴스는 레코드의 집합임

레코드간의 순서는 의미가 없음 - '첫번째 레코드', '두번째 레코드'란 표현은 의미 없음

레코드 내에서 필드의 순서는 의미가 없음 - 테이블 스키마는 필드의 집합으로 표현됨

모든 필드는 원자값을 가짐

## 키

레코드간의 순서가 의미 없으므로 레코드를 구분하기 위해서는 각 레코드의 값이 이용됨.

키
  - 필드들의 일부로 각 레코드들을 유일하게 식별해낼 수 있는 식별자
  - 일반적으로 하나의 필드를 지정하여 키로 지정하나, 여러 개의 필드들로 키를 구성할 수도 있음
    - 두 개 이상의 레코드로 구성된 키를 복합키라고 함.
  - 신입생 테이블의 학번 또는 주민등록번호 필드는 각 레코드간에 유일하므로 키가 될 수 있으나 학과명은 키가 될수 없음

관계형 데이터 모델에서 특정 레코드를 구별하거나 탐색하기 위한 유일한 방법

## 슈퍼키, 후보키, 기본키의 개념

슈퍼키 - SK : 아무런 제약 조건 없이 레코드들을 식별할수 있는 필드의 집합  
후보키 - CK : 최소한의 필드만으로 구성된 키  
기본키 - PK : 후보키 중에서 식별자로 정의한 하나의 키, 되도록 하나의 필드로 구성된 후보키를 선정하는 것이 유리함.

## 키가 널이 될 수 있나?

기본키는 식별자의 기능을 함

기본키로 정의된 필드가 널을 갖게 되면 식별 기능을 상실.  
예를 들어 두 개의 레코드에 대한 기본키 값이 동시에 널(null)일 경우 그 두 개의 레코드는 서로 구별할 수 없게 된다. 그렇기 때문에 기본키는 널이 될 수 없다.

## 외래키-FK

두 테이블 간의 관계를 나타낸다. 다른 테이블의 기본키를 참조하는 필드 집합니다.참조하는 테이블이 만약 외래키값이 널이 된다는 것은 알지 못하거나 아직 결정되지 않았다는 것을 의미한다.

참조하는 테이블과 참조되는 테이블의 도메인이 같아야 하며 null값은 허용하지만 잘못된 값은 허용 하지 않으니 주의 해야한다.

자신의 테이블을 참조하는 외래키가 있을 수 있다. 즉, 자가레퍼런스가 가능하다는 것이다.

## 관계형 데이터베이스

관계형 데이터 모델에 기반하여 하나 이상의 테이블로 실세계를 표현한 데이터 베이스를 관계형 데이터베이스라고 말한다. 관계형 데이터베이스가 하나 이상의 테이블로 구성되어 있을 때, 데이터베이스 스키마는 테이블 스키마의집합이며, 데이터베이스 인스턴스는 테이블 스키마들에 대한 테이블 인스턴스들의 집함을 의미한다.


## 관계 대수

질의어 - Query Language : 삽입, 삭제, 수정, 검색 등의 데이터 조작을 위한 연산들을 표현하기 위한 언어

관계형 데이터베이스에서의 대표적 질의어
  - 관계 대수
    - 절차적 언어
    - 수학에서의 수식구조와 유사
    - 피연산자 : 테이블
    - 연산자
      - 단항 연산자
      - 이항 연산자 : 대부분 두개의 피연산자로 관계 구성

## 관계대수의 연산 종류

기본 연산 - 5개 연산지원 : 완전한 관계형 데이터베이스
  - 선택 연산 : 단항 연산
  - 추출 연산
  - 재명명 연산
  - 집합 연산
  - 카티션 프로덕트
추가 연산
  - 조인
  - 자연 조인
  - 외부 조인
  - 지정 연산
  - (나누기 연산)

## 선택

하나의 테이블에서 주어진 조건을 만족하는 레코드들을 검색하는 기능

>σ<sub><조건식></sub>(<테이블이름>)


<테이블이름> : 연산의 대상이 되는 테이블의 이름
<조건식> : 비교연산자와 부울 연산자의 조합

>예시  
>σ<sub>address = '서울'</sub>(student)

steudent테이블에서 address가 '서울'인 레코드를 검색


## 선택 연산에서 널을 처리

만약 조건식에서 참조하는 컬럼에 널 값이 입력되어 있을 경우 조건에서 선택이 안된다. 즉, 결과가 나오지 않는다.

## 추출

테이블에서 사용자가 원하는 필드만을 결과로 출력하는 연산

>π<sub><필드리스트></sub>(<테이블이름>)

<테이블 이름> : 연산의 대상이 되는 테이블의 이름
<필드 리스트> : 테이블에서 추출하고자 하는 필드들의 리스트

>π<sub>sut_id, name</sub>(student)

student 테이블에서 stu_id와 name만을 추출
중복을 제거해야 한다. 관계형 모델은 중복된 레코드들을 허용하지 않기 때문이다.

## 연산자들의 조합

관계 대수 연산자들은 상호 중첩하여 사용 가능

>σ<sub>position = '부교수'</sub>(σ<sub>year_emp>= 2000</sub>(professor))

2000년 이후에 임용된 '부교수'들의 레코드를 검색

## 연사자들의 조합

선택 연산은 교환 법칙이 성립

>σ<sub><조건식1></sub>(σ<sub><조건식2></sub>(<테이블이름>)) ≡ σ<sub><조건식2></sub>(σ<sub><조건식1></sub>(<테이블이름>))

추출 연산에 대해서 다음의 두 질의는 동일한 결과

>π<sub>name, position</sub>(π<sub>prof_id, position</sub>(professor))  
>π<sub>name, position</sub>(professor)

다음은 잘못된 질의임

>π<sub>prof_id, name, position</sub>(π<sub>name, position</sub>(professor))  
>π<sub>name, position</sub>(professor)의 결과에 prof_id를 포함하고 있지 않기 때문에

><필드리스트1>⊂<필드리스트2>  
>π<sub><필드리스트1></sub>(π<sub><필드리스트2></sub>(<테이블이름>)) ≡ π<sub><필드리스트1></sub>(<테이블이름>)

일반적으로 선택과 추출 연산의 조합으로 질의를 표현

>π<sub>name</sub>(σ<sub><year_emp>= 2000 ∧ position = '부교수'></sub>(<테이블이름>))

## 재명명 연산

테이블에 이름을 부여하거나 변경하는 연산

>ρ<sub><테이블명1></sub>(<테이블명2>)

<테이블명2>의 이름을 <테이블명1>로 변경하라는 의미

>ρ<sub><테이블명1>(<필드리스트>)</sub>(<테이블명2>)

<테이블명2>의 이름을 <테이블명1>로 변경하는 동시에 <테이블명2>에 정의된 필드명들을 모두 <필드리스트>로 변경

>π<sub>com_dept.name</sub>(ρ<sub>com_dept</sub>(σ<sub>dept_id = '920'</sub>(class)))

professor 테이블에서 dept_id가 '920'인 교수들의 이름을 검색

>ρ<sub>class301(id, number)</sub>(π<sub>prof_id, enroll</sub>(σ<sub>classroom = '301'</sub>(class)))

강의실이 '301호'인 class의 prof_id와 enroll을 검색

-주의
  - 재명명 연산은 중간 결과나 최종 결과에 대한 테이블명이 변경됨
  - 본래 데이터베이스에 저장된 테이블명까지 변경되는 것은 아님

## 집합 연산

수학적 집합 이론에서 정의된 연산
  - 합집합
  - 차집합
  - 카티션 프로덕트
  - 교집합 → 차집합으로 정의할 수 있음

호환 가능한 테이블들
  - 합집합, 차집합, 교집합 연산에서 두 피연산자의 차수와 필드 이름들이 동일해야 함
  - 같은 이름의 필드들이라 하더라도 도메인이 일치해야 함

## 합집합(∪)

학생 또는 교수들의 이름과 소속 학과 번호를 모두 검색

>π<sub>name, dept_id</sub>(student) ∪ π<sub>name, dept_id</sub>(professor)

## 교집합(∩)

교과목 중에서 한번 이상 개설된 과목에 대한 교과목 번호를 검색

>π<sub>course_id</sub>(course) ∪ π<sub>course_id</sub>(class)

## 차집합(-)
강좌가 개설되지 않은 과목에 대한 교과목 번호를 검색

>π<sub>course_id</sub>(course) - π<sub>course_id</sub>(class)

## 카티션 프로덕트

두 개의 테이블에서 각각의 레코드들을 서로 결합하여 하나의 레코드로 구성하면서 가능한 모든 조합의 레코드들로 테이블을 생성

><테이블명1>×<테이블명2>

두 개 이상의 테이블이 필요한 질의의 표현이 가능

>π<sub>professor.name, department.dept_name</sub>(σ<sub>professor.dept_id = department.dept_id</sub>(professor × department))

교수들의 이름과 소속된 학과 이름을 검색

교환법칙과 결합법칙이 성립함

## 추가연산

조인(세타 조인)
자연 조인
외부 조인
지정 연산

## 조인

두 테이블로부터 특정 조건을 만족하는 레코드들을 하나의 레코드로 결합하는 연산  
카티션 프로덕트는 모든 가능한 조하ㅏㅂ에 의해 레코드들을 생성하지만 조인은 특정 조건을 만족하는 레코드만을 선택

세타(θ) : 조인이라고도 함

> <테이블이름1>⋈<sub>조건식</sub><테이블이름2>

<조건식> : 조인조건이라 부름
- 조인 조건은 필드간의 동등비교(=)가 대부분이며 이를 동등조건이라 함

> <테이블이름1>⋈<sub>조건식</sub><테이블이름2> ≡ σ<sub>조건식</sub>(<테이블명1>×<테이블명2>)

><student>⋈<sub>student.dept_id = department.dept_id</sub><department>

학생과 학생이 소속된 학과에 관한 정보를 검색

## 자연 조인

서로 다른 테이블에서 같은 이름을 갖는 두 필드에 대한 동등 조인 중 하나의 필드를 제거하여 단순히 표현한 연산, 중복된 필드 제거

><테이블이름1>⋈<테이블이름2>

공통되는 필드가 없으면 카티션 프로덕트와 같음

카티션 프로덕트와 자연조인은 이론상 동일하지만 속도는 조인이 우세

## 외부 조인

조인 조건에 만족되지 않은 레코드까지 검색 결과에 포함시키기 위한 방법
서로 매치되지 않는 필드에 대해서는 NULL을 입력함

## 지정 연산

복잡한 질의를 여러 개의 질의로 분리하거나 중간 결과(임시저장공간)에 이름을 부여  
최종 질의를 결과에 이름을 부여  
연산 기호로는 ←를 사용
