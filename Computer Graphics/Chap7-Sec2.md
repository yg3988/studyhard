# 투상 변환과 뷰 포트 변환

## 지엘의 투상 변환

### 투상 변환

모델 변환과 시점 변환을 행렬로 표시한 것이 모델 뷰 행렬이라면, 투상 변환을 행렬로 표시한 것은 **투상 행렬** 이다. 따라서 투상 방법에 따라 투상 행렬의 내용이 바뀐다.

행렬 모드를 설정하지 않을 경우의 기본값은 모델 뷰 행렬이다. 투상을 가하기 위해서는 반드시 투상 행렬을 매개변수로 넣고 호출해야한다.

`void glMatrixMode(GL_PROJECTION)`

전에 적었다시피 투상 행렬 스택은 최소 2개 이상이고 스택의 맨 위에 있는 것이 현 변환 행렬이다. 투상 행렬의 현 변환 행렬로, 모델 뷰 행렬의 현 변환 행렬과는 완전히 별개의 행렬임에 유의해야 한다.

모델 뷰 행렬에 대한 작업이나 투상 행렬에 대한 작업 모두가 기하 변환에 속하므로, 동일한 지엘 함수를 통해 이루어진다. 따라서 프로그래머는 행렬 모드 설정에 의해, 현재 어떤 행렬에 작업을 가하는지 분명히 해야한다. 함수 호출 순서는 모델 뷰 변환과 투상 변환은 어떤 것이 먼저 오더라도 무관하다. 이는 모델 뷰 변환과 투상 변환이 조작하는 대상 행렬이 서로 다르기 때문이다.

### 지엘의 평행 투상

지엘의 카메라는 기본적으로 -z 방향을 바라본다. 평행 투상에서 투상선은 z축과 나란히 진행하므로 점 P는 점P′ 위치로 투상된다.

z값이 클수록 시점에서 멀어진다는 점에서 z를 '물체의 깊이'라고도 한다. 실제로 눈에 보이는 것은 가까운 것, 즉 깊이가 작은 것이다. 그런데 만약 변환을 가하게 되면 깊이가 d로 바뀌어 원래 좌표에 포함된 깊이 정보를 잃게 된다.

한 번 가한 변환을 취소하고 원래의 값으로 되돌릴 수 없는 변환을 **특이 변환** 이라 한다. 한 번 투상되면 그것이 어디에서 왔는지, 즉 z값이 원래 얼마였는지를 회복할 수 없다는 말이다. 평행 투상에서의 이러한 변환은 실제로는 무의미하다. 원래의 좌표 (x, y, z, 1)를 그대로 둔 채 (x, y)만 읽어 내면 그것이 투상된 2차원 좌표이기 때문이다. 투상 이후의 파이프라인에서 깊이 정보를 활용하기 위해 지엘은 이러한 변환을 가하지 않는다. 즉, 투상 결과 여전히 3차원 좌표가 유지된다.

### 평행 투상의 가시 부피 설정

실제 투상에서는 투상 범위를 항상 제한해야 한다. 제한된 크기의 뷰 윈도우에 모든 물체의 영상이 맺히게 할 수는 없기 때문이다. 투상 범위를 **가시 부피** 라 부른다. 투상선에 수직으로 놓인 평면 중, 시점에서 가까운 쪽을 **전방 절단면**, 시점에서 멀리 떨어진 면을 **후방 절단면** 이라 한다. 뷰 윈도우 모서리를 지나가는 4개의 투상선과 전후방 절단면에 의해 형성되는 육면체가 바로 형행 투상의 가시 부피다.

6개의 면으로 구성된 가시 부피 안에 있는 물체만 투상된다. 즉, 가시 부피 밖에 있는 물체는 일체 보이지 않는다. 어떤 물체가 가시 부피 안팎에 걸쳐 있으면 밖에 있는 부분은 절단 되어 버려지고, 안에 있는 부분만 투상되어 보이게 된다. 평행 투상의 가시 부피 설정을 위한 지엘 함수는 다음과 같다.

`void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);`

파라미터 left, right, bottom, top, near, far는 각각 가시 부피의 좌ㆍ우ㆍ하ㆍ상ㆍ전ㆍ후를 뜻한다. `glOrtho()`함수에서 전후방 절단면의 위치를 표시하는 near와 far 값은 반드시 양수로 나타낸다. 이는 시점으로부터의 절단면까지의 거리이기 때문이다. 그러나 시점 좌표계는 오른손 법칙을 따르기 때문에 near와 far값에 (-1)을 곱해야만 실제 z좌표가 나온다. 다시말해 실제 전방절단면의 z 좌표는 -near, 후방 절단면의 z 좌표는 -far이다.

### 정규화 가시 부피

지엘은 가시 부피를 그대로 사용하는 대신 다른 모습으로 편환하여 사용한다. 지엘의 **정규화 변환** 은 가시 부피의 모습을 바꾸는 변환이다. `glOrtho()`의 파라미터로 정의된 가시 부피를 가로, 세로, 높이가 2인 정육면체로 투상하는 변환이다. 변환 결과인 정육면체를 **정규화 가시 부피** 라고 한다. 정규화 변환 결과 시점 좌표계 원점은 정규화 가시 부피의 정중앙에 위치한다. 여기서 유의할 점은 정규화 가시 부피의 시점 좌표계다. 변환 이전 시점 좌표계가 오른손 법칙을 사용하는데 반해, 변환 이후 시점 좌표계는 왼손 법칙을 사용한다. 이 규칙에 따르면 정규화 가시 부피의 좌하단 좌표는 (-1, -1, -1), 우상단 좌표는 (1, 1, 1)이 된다.

지엘에서 가시 부피 그대로 사용하지 않고 정규화 가시 부피를 사용하는 이유는 3가지다.
1. 평행 투상, 원근 투상 모두 동일한 모습의 정규화 가시 부피를 사용함으로써 파이프라인 처리구조가 동일해지기 때문
2. 가시 부피 밖의 물체를 절단하는데 있어서 정육면체를 기준으로 하는것이 훨씬 단순하다.
3. 시점 좌표계 원점을 기준으로 가로, 세로 길이를 1로 정규화함으로써 화면 좌표계로 변환하기 수월해지기 때문

정규화 변환으로 인하여 가시 부피는 물론 가시 부피 내의 물체도 정규화된다. 다시 말해 물체 정점 좌표가 바뀐다. 정규화된 좌표계를 **절단 좌표계** 라고 부르며 절단 좌표계는 왼손 법칙을 따른다.

### 원근 투상

동차 좌표를 실제 3차원 좌표로 환원하는 작업을 **원근 분할** 이라고 한다. 다시 말해 동차 좌표에 원근분할을 가하면 실제로 그 동차 좌표가 의미하는 3차원 좌표를 얻게 된다. 우리가 필요로 하는 것은 3차원 좌표다. 그럼에도 불구하고 3차원 좌표값에서 동차 좌표로 만들었다가 원근 분할로 다시 실제 3차원 좌표값으로 환원하는 이유는 절단 작업 때문이다. 절단 작업은 동차 좌표 공간에서 가해지기 때문이다.  
원근 투상을 하다보면 2차원 x′, y′만 남게 되고, z 성분은 무시된다. x′, y′ 성분을 보면 각각 x/(z/d), y/(z/d)로, z값이 커질수록 투상된 x, y성분이 작아진다. 원근 투상에서는 먼 곳에 있는 물체, 즉 z값이 큰 물체일수록 투상의 결과가 작게 보여야 하는 점에서 이는 당연한 결과다. 또 평행 투상에서는 시점에서 투상면까지의 거리 d와 무관하게 x,y 값이 동일한데 반해, 여기서 d에 비례하여 x, y값이 커진다.

원근 변환 행렬은 행령의 마지막 행이 (0, 0, 0, 1)이 아닌 (0, 0, 1/d, 0)이기 때문에 이는 어파인 변환이 아니다. 어파인 변환의 특징 중 하나는 평행한 선분은 변환 후에도 평행 하다는 것이다. 그러나 원근 변환에서는 평행한 선분이 한 점에서 만나기도 한다는 점에서 이러한 특성이 유지되지 않는다.

원근 변환의 과정을 살펴보면 x′ = x/(z/d)로서 변환 후의 x값이 변환 전의 x값에 (d/z)를 곱한 형식이다. 선형 변환의 정의가 변환 전의 변수에 상수 배 한 것의 합이라는 점에 비춰보면, 이 변환은 당연히 비선형 변환이다. 그러나 동차 좌표의 관점에서 바라보면 비선형 변환으로 보이지 않는다. 따라서 원근 변환은 동차 좌표 관점에서 바라보면 선형 변환이지만, 3차원 좌표 관점에서 바라보면 비선형 변환이다.

### 원근 투상의 가시 부피 설정

펴앵 투상과 마찬가지로 지엘의 원근 투상에서도 항상 투상 범위를 제한해야 한다. 지엘의 원근 투상에서 투상면과 전후방 절단면은 시점으로부터 초점을 향한 선, 즉 시선에 수직으로 놓인다. 시점이 물체로부터 유한한 거리에 있다고 가정하는 원근 투상에서는 투상선이 방사형으로 퍼져 나간다. 가시 부피가 육면체인 점에서는 평행 투상과 동일하지만 그 모습은 다르다. 즉, 후방 절단면을 밑면으로 하고 시점의 정점으로 하는 위가 잘린 **절단 사각 뿔** 의 모습니다. 머리가 잘린 모습이라는 뜻에서 **절두체** 라고도 한다.

지엘은 원근 투상의 가시 부피도 평행 투상과 동일한 모습의 정규화 가시 부피로 변환한다. 즉, 잘린 사각뿔을 단위 길이가 2인 정육면체로 변환한다. 평행 투상, 원근 투상을 막론하고 정규화 변환은 특이 변환이다. 정규화 가시 부피로 바뀌면 지엘은 평행 투상과 원근 투상을 동일한 방식으로 취급한다. 따라서 투상의 최종 단계인 3차원 정규화 가시 부피로부터 2차원 투상면으로의 투상은 단순히 z값을 무시하는 투상, 즉 평행 투상이 된다. 평행 투상을 다루는 함수가 `glOrtho()`이라면 원근 투상 함수는 아래와 같다.
```
void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
void gluPerspective(GLdouble fov, GLdouble aspect,  GLdouble near, GLdouble far);
```

평행 투상과는 다르게 원근 투상 함수는 두 가지다. 그 중 하나는 `glFrustum()`함수로, 파라미터 순서대로 가시 부피의 좌ㆍ우ㆍ하ㆍ상ㆍ전ㆍ후가 정의 된다. `gluPerspective()`함수는 `glFrustum()`함수와 다른 점은 가시 부피의 위치다. 즉, `gluPerspective()`에서는 시선이 정확히 가시 부피의 중심으로 통과하며, 가시 부피가 시선을 기준으로 대칭적으로 놓이는 데 반해 `glFrustum()`함수에서는 그러한 제약 조건이 없다.

`gluPerspective()`함수는 `glFrustum()`함수 보다 더욱 직관적이고 손쉽다는 장점이 있다. 위에서 말한거처럼 `gluPerspective()`함수에서의 시선이 가시 부피의 한가운데 통과한다. 즉, 시선을 중심으로 가시 부피는 대칭적으로 존재한다고 가정하자. 파라미터 fov는 시야를 의미한다. 이는 상하 y축 방향의 시야각을 도(degree)로 나타낸 것으로, 0~180도 범위를 갖는다. aspect는 뷰 윈도우의 종횡비로 폭을 높이로 나눈 값이므로 엄밀히 말하면 횡종비라 할수 있다. 물체의 모습이 왜곡되는 것을 방지하려면 이 종횡비가 뷰 포트의 종횡비와 같아야 한다. near와 far는 전방 절단면 및 후방 절단면에 해당하는 것으로, 다른 투상 함수와 마찬가지로 값이 항상 양수이어야 한다. near의 값이 다른 값의 분모에 영향을 주니 0으로 하는 것은 지양해야 한다.
