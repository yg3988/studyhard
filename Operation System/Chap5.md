# 병행성 : 상호배제와 동기화

##### 병행성과 관련 있는 주요 용어

![os32](https://user-images.githubusercontent.com/31890257/48316317-8ab38780-e625-11e8-8853-63806220d96f.JPG)

## 병행성 원리
&nbsp;&nbsp;&nbsp;&nbsp;병행성이란 다수 프로세스(또는 쓰레드)들이 동일 시간대에 수행되는 상황을 나타내는 용어로 멀티프로그래밍, 멀티 프로세싱 두 가지의 처리방식이 있다. 하지만 이 두 방식은 같은 문제를 야기한다.
1. 상호배제 문제
2. 동기화 문제
3. 교착상태 문제
4. 기아상태 문제


&nbsp;&nbsp;&nbsp;&nbsp;단일처리기 멀티프로그래밍 시스템에서, 프로세스들은 인터리빙된다. 즉 여러 프로세스들이 서로 번갈아가면서 수행되는 것이다. 인터리빙은, 비록 실제로 병렬 처리되는 것은 아니며 프로세스들 간에 문맥 교환을 위한 비용이 발생하지만, 시스템의 처리 효율과 구조적인 프로그래밍에 큰 장점을 제공한다. 멀티프로세서 시스템에서는 프로세스들의 인터리빙뿐만 아니라 오버래핑도 지원한다.

&nbsp;&nbsp;&nbsp;&nbsp;두 기법은 동일한 문제를 야기한다. 단일 프로세서 시스템의 경우, 문제는 멀티프로그래밍의 기본 특징, 즉 프로세스들의 수행의 상대 속도를 예측할 수 없다는 특징에서 발생한다. 프로세스들이 수행되는 상대 속도는 운영체제의 스케줄링 정책과 다른 프로세스들의 활동, 그리고 운영체제가 인터럽트를 처리하는 방법 등에 따라 동적으로 변한다.

동적으로 변하는 특징은 프로그램 개발 시에 다음과 같은 어려움을 야기한다.

* 전역 자원의 공유에 어려움이 발생한다.
* 운영체제가 자원을 최적으로 할당하기 어려워진다.
* 프로그래밍 오류를 찾아내는 것이 어려워진다.

&nbsp;&nbsp;&nbsp;&nbsp;이와 같은 어려움은 멀티프로세서 시스템에서도 발생한다. 멀티프로세서 시스템도 프로세스들에 대한 수행의 상대속도를 예측할 수 없기 때문이다. 그 이유는 첫째, 다른 프로세서들의 활동. 둘째, OS가 인터럽트를 처리하는 방법. 셋째, OS 마다 다른 스케줄링 정책에 있다.

### 경쟁 상태

&nbsp;&nbsp;&nbsp;&nbsp;다수의 프로세스나 쓰레드가 공유 자원을 동시에 읽거나 쓰려고하는 상태를 경쟁상태라고 한다. 경쟁상태가 발생하면 최종 수행 결과는 프로세스들의 수행 순서에 따라 달라진다.

&nbsp;&nbsp;&nbsp;&nbsp;두 개의 프로세스 P1과 P2가 전역변수 a를 공유한다. P<sub>1</sub>과 P<sub>2</sub>가 전역 변수 a를 공유한다. 수행 중 P<sub>1</sub>은 전역변수 a를 값 1로 수정하며, P<sub>2</sub>는 전역변수 a를 값 2로 수정한다. 결국 두 프로세스 P<sub>1</sub>과 P<sub>2</sub>가 전역변수 a를 접근하기 위해 서로 경쟁하고 있는 상태이며, 이 경쟁에서 진 프로세스, 즉 마지막으로 변수에 접근한 프로세스의 수정결과가 전역변수 a의 최종 저장 값이 된다. 구체적으로 만일 P<sub>2</sub>의 수정 연산이 더 늦게 수행됬다면 전역 변수 a는 값 2를 갖게 된다.

&nbsp;&nbsp;&nbsp;&nbsp;다른 예제는 b = 1, c = 2로 초기화 된 전역 변수를 공유하는 두 개의 프로세스 P<sub>3</sub>와 P<sub>4</sub>를 고려해보자. 수행 중 P<sub>3</sub>은 `b = b + c` 연산을 수행한다. 반면 P<sub>4</sub>는 `c = b + c` 연산을 수행한다. 이 예에서도 수행 결과는 P<sub>3</sub>와 P<sub>4</sub>의 수행 순서에 따라 결정된다. 만일 P<sub>3</sub>이 먼저 수행하게 되면 최종 수행 결과는 `b = 3, c = 5`가 되고, P<sub>4</sub>가 연산을 먼저 수행하게 되면 최종 수행 결과는 `b = 4, c = 3`이 된다.

### 운영체제의 고려사항들

&nbsp;&nbsp;&nbsp;&nbsp;병행성이 야기하는 운영체제의 설계와 관리 이슈
1. 모든 프로세스들의 상태와 수행 위치를 추적
  * 코드 실행ㆍ중지 위치를 추적 - PCB
2. 활동 중인 각 프로세스에 다양한 자원들을 할당하고 해제
  * 수행ㆍ준비ㆍ블락
3. 각 프로세스에 할당된 물리 자원과 데이터들을 보호
4. 프로세스의 기능과 수행 결과는 수행 속도와 독립

### 프로세스 간 상호작용 방법

* 서로 인식하지 못하는 프로세스들 : 이들은 협동 작업을 하지 않는 서로 독립적인 프로세스들이다. 다수 독립적인 프로세스들로 구성된 멀티프로그래밍 환경이 대표적인 예이다. 각 프로세스들은 일괄 작업을 수행할 수도 있고, 대화형 작업을 수행할 수도 있으며, 이 두 형태가 혼합된 작업을 수행할 수도 있다. 비록 프로세스들은 서로 협동 작업을 수행하지는 않지만, 운영체제는 프로세스들 간에 자원에 대한 경쟁을 고려해야만 한다.
  * 발생가능한 제어 문제
    * 상호 배재
    * 교착 상태(재사용 가능한 자원)
    * 기아 상태

* 서로를 간접적으로 인식하고 있는 프로세스들 : 이들은 다른 프로세스들의 이름을 알고 있지는 않지만, 입출력 버퍼와 같은 자원을 공유하는 프로세스들이다. 프로세스들은 서로 간에 공통 자원 공유를 통한 협력 관계를 갖는다.-공유를 통한 협력
  * 발생가능한 제어 문제
    * 상호 배재
    * 교착 상태(재사용 가능한 자원)
    * 기아 상태
    * 데이터 일관성

* 서로를 직접적으로 인식하고 있는 프로세스들 : 이들은 다른 프로세스들의 이름을 알고 있으며, 이를 이용해 직접 통신한다. 이들은 공통된 작업을 함께 수행하기 위해 설계되었으며 역시 협력 관계를 갖는다.- 통신을 통한 협력
  * 발생 가능한 제어 문제
    * 교착 상태(소모성 자원)
    * 기아 상태

#### 자원에 대한 프로세스간 경쟁
  * 병행 프로세스들이 동일한 자원을 동시에 접근하려는 경우 경쟁 발생
  * 각 프로세스는 다른 프로세스의 수행 결과에 영향을 받지 않아야 함
  * 각 프로세스는 사용한 자원의 상태를 변화시켜서는 안된다.
  * 프로세스의 수행은 경쟁 관계인 다른 프로세스의 행위에 영향을 줌
  * 발생 가능한 제어 문제들
    * 상호 배재
    * 교착 상태
    * 기아

  * 임계자원(= 공유자원) : 두 개 이상의 프로세스가 동시에 사용할 수 없는 자원
  * 임계영역 : 임계자원을 접근하는 프로그램 코드의 일부분
  * 상호배재 : 한 시점에 단 하나의 프로세스만이 임계영역에 진입할 수 있다는 것을 의미
  * 상호배제의 보장은 교착상태를 발생시킴
  * 시스템에 프로세스 P<sub>1</sub>, P<sub>2</sub>가 와 각각 1개 뿐인 두 자원 R<sub>1</sub>, R<sub>2</sub>가 있다고 가정하자
    * 자원 할당 경우 1 : P<sub>1</sub>에 R<sub>1</sub>이 할당되어 있고, R<sub>2</sub>의 할당을 요청하였음. P<sub>2</sub>에 R<sub>2</sub>가 할당되어 있고 R<sub>1</sub>의 할당을 요청하였음.
  ![os33](https://user-images.githubusercontent.com/31890257/48316318-8ab38780-e625-11e8-91c9-a29f5f3d4fdc.JPG)
  * 상호배제의 보장은 기아 상태를 발생시킴
  * 시스템에 프로세스 P<sub>1</sub>, P<sub>2</sub>, P<sub>3</sub>와 1개 뿐인 어떤 자원이 있다고 가정하자.
    * 자원 할당 경우 2 : 주기적으로 수행되는 P<sub>1</sub>, P<sub>2</sub>만 필요한 자원을 할당 받아서 수행을 완료하며, 나머지 P<sub>3</sub>은 무한히 자원을 할당 받지 못함.
  ![os34](https://user-images.githubusercontent.com/31890257/48316319-8b4c1e00-e625-11e8-8b67-e36a9a823643.JPG)

#### 공유를 통한 협력
  * 프로세스들은 서로를 명시적으로 알지 못하지만 상호 협력함
  * 이유 : 공유 변수, 공유 파일, 공유 데이터베이트 접근
  * 상호 협력 제어 기법은 공유 데이터의 무결성을 보장함
  * 공유 데이터가 공유자원에 저장되기 때문에 상호 배제, 교착상태, 기아상태 문제 발생
    * 상호배재 보장은 공유 데이터에 대한 쓰기 연산에만 필요함
  * 공유를 통한 협력에서는 데이터 일관성 문제가 발생함

##### 예 : 공유 데이터 a, b에 대해 a = b라는 조건이 유지되도록 갱신 되어야 한다고 가정
  ![os35](https://user-images.githubusercontent.com/31890257/48316320-8b4c1e00-e625-11e8-82b1-f145d1cf513d.jpg)

#### 통신을 통한 협력

* 모든 프로세스들이 서로 인식하며, 동기화와 같은 공통의 목표를 위해 프로세스 간 상호 협력
* 통신을 위해 프로그래밍 언어나 OS는 메세지를 송수신할 수 있는 기본 연산자를 제공함
* 메시지를 주고 받을 때 프로세스들 간에 상호배제는 발생하지 않음
* 교착상태 발생 예 : 두 프로세스가 메시지를 보내지 않고서 서로 메시지를 기다리고 있는 경우
* 기아 발생 예 : 세 개의 프로세스 중 두 프로세스만이 반복적으로 상호 메시지를 주고 받는 경우

### 상호 배제 요구 조건
---
* 상호배제가 강제되어야 한다.
* 임계영역이 아닌 곳에서 수행이 멈춘 프로세스는 다른 프로세스의 수행을 간섭해서는 안된다.
* 임계영역에 접근하고자 하는 프로세스의 수행이 무한히 미루어져서는 안 된다.
* 임계영역이 비어 있을 때, 임계영역에 진입하려고 하는 프로세스는 즉시 임계영역에 들어갈 수 있어야 한다.
* 프로세스의 수나 프로세스 상대 수행 속도에 대한 가정은 없어야 한다.
* 일단 임계영역에 들어간 프로세스는 일정한 시간 내에 임계영역에서 나와야 한다.

#### 상호배제 요구조건을 만족시키는 접근 방법
* 소프트웨어적인 접근 방법
  * 병행 수행하려는 프로세스들이 서로 협력을 통해 직접 상호배제를 보장하는 방법
  * Dekker 알고리즘, Perterson 알고리즘
* 하드웨어적인 접근 방법
  * 특별한 용도로 설계된 기계어를 이용하여 상호배제를 보장하는 방법
  * 인터럽트 금지, Test&Set, Compare&Swap, Exchange 명령어
* 범용 접근 방법
  * OS나 프로그래밍 언어 수준에서 상호배제를 보장하는 방법
  * Semaphore, Monitor, Message Passing

### 상호배제 : 소프트웨어 접근 방법

![os36](https://user-images.githubusercontent.com/31890257/48316321-8b4c1e00-e625-11e8-8f77-c4b366421e4b.JPG)
![os37](https://user-images.githubusercontent.com/31890257/48316322-8b4c1e00-e625-11e8-8928-6672bd62f57c.JPG)

### 상호배제 : 하드웨어 접근 방법

* 인터럽트 비활성화, 특별한 기계 명령어를 이용하여 프로세스들 간에 상호배제 요구조건을 보장하게 하는 기법
* 인터럽트 금지
* 특별한 기계 명령어
  * Compare&Swap 명령어
  * Exchange 명령어
  * Test&Set 명령어

#### 인터럽트 금지
싱글코어에서만 가능하다.

* 프로세스가 임계 영역에 있는 동안 인터럽트의 발생을 허용하지 않음
* 수행 중인 프로세스 중단 : 인터럽트, 트랩, 슈퍼바이저 호출

![os38](https://user-images.githubusercontent.com/31890257/48316323-8be4b480-e625-11e8-8bc7-9ad1718b0860.JPG)
![os39](https://user-images.githubusercontent.com/31890257/48316324-8be4b480-e625-11e8-8c19-3e7e15fcfe0a.JPG)

* 단일 프로세서 상에서 상호배제는 보장됨
  * 프로세서가 임계영역 코드를 수행하려고 할 때 인터럽트를 허용 하지 않음

* 단점
  * 수행 효율성이 현저히 감소됨
    * 외부 사건에 대한 처리, 스케줄링 등 모든 기능이 중지됨
  * 멀티프로세서 시스템에서는 상호배제를 보장할 수 없음
    * 오늘날 OS는 SMP를 지원함
    * 인터럽트 금지 메시지를 모든 프로세서에 전달 → 상당한 시간 소비, 임계 영역 진입 지연 발생

#### 특별한 기계 명령어

* 특정 메모리 주소가 접근되고 있을 때 같은 위치에 대한 다른 접근 요청은 차단됨
* 하나의 명령어 인출 사이클 동안 같은 메모리 위치에 대한 읽기-쓰기 또는 테스트-쓰기 동작을 원자적으로 처리

![os40](https://user-images.githubusercontent.com/31890257/48316325-8be4b480-e625-11e8-82dd-5d2e583ad817.JPG)
![os41](https://user-images.githubusercontent.com/31890257/48316326-8be4b480-e625-11e8-8ba5-fd1efef17e98.JPG)

* 특별한 기계 명령어 장점
  * 임의 개수의 프로세스에 적용 가능
  * 단일프로세서와 공유 메모리 기반 멀티프로세서에 모두 적용 가능
  * 간단하고 검증하기 쉬움
  * 서로 다른 변수를 사용하면, 다중 임계영역 지원 가능
* 특별한 기계 명령어 단점
  * 임계영역 진입 대기 시 바쁜 대기 기법을 씀
  * 기아 상태 발생 가능
  * 교착 상태 발생 가능(우선순위 기반 스케줄링 경우)

### 세마포어

* Dijkstra 기법의 기본적인 원리
  * 두 개 이상의 프로세스들은 시그널을 이용하여 협동할 수 있도록 함
  * 한 프로세스가 특정 시그널을 수신할 때까지 정해진 위치에서 중지하도록 강제함

시그널을 위해 세마포어라는 변수 사용

>semWait(s) : 프로세스 s를 통해 시그널을 수신하기 위한 연산 정의  
>semSignal(s) : 프로세스가 s를 통해 시그널을 전송하기 위한 연산 정의

* 정의
  * 세마포어는 정수값을 갖는 변수로 다음 3가지 연산을 통해 접근 가능함 - 정보 은닉
    * 세마포어 초기화 : 세마포어(s)값을 음이 아닌 값으로 초기화 한다.
    * semWait(s) : 세마포어(s) 값을 감소시킨다. 만일 s 값이 음수가 되면 호출한 프로세스는 블록된다.
    * semSignal(s) : 세마포어(s) 값을 증가시킨다. 만일 s값이 양수가 아니면 블록된 프로세스를 깨운다.

![os42](https://user-images.githubusercontent.com/31890257/48316327-8c7d4b00-e625-11e8-9e7a-0667deb82ee0.JPG)

#### 이진 세마포어

* 이진 세마포어는 오직 0과 1의 값을 갖는 변수
  * 세마포어 초기화 : 세마포어 값을 0이나 1로 초기화한다.
  * semWaitB(s) : 세마포어 값을 확읺다나. (1)세마포어 값이 0이면 semWaitB를 호출한 프로세스는 블록된다. (2)세마포어 값이 1이면 0으로 변경시키고 프로세스는 계속 수행된다.
  * semSignalB(s) : 블록되어있는 프로세스가 있는지 확인한다. (1)존재한다면 블록된 프로세스를 깨운다. (2)존재하지 않으면 세마포어값을 1로 설정한다.

![os43](https://user-images.githubusercontent.com/31890257/48316328-8c7d4b00-e625-11e8-829e-9242fc0f7064.JPG)

##### 세마포어 동작 예

![os44](https://user-images.githubusercontent.com/31890257/48316329-8c7d4b00-e625-11e8-913d-296068f76df5.JPG)

* 프로세스 A, B, C는 데이터 소비
* 프로세스 D는 데이터 생성
* s는 D가 생성한 데이터 존재 여부
  * s는 Semaphore를 의미

### 상호 배제

![os45](https://user-images.githubusercontent.com/31890257/48316330-8c7d4b00-e625-11e8-8ffc-fd765f70fc99.JPG)

위 그림은 세마포어 s를 이용하여 상호 배제 문제를 해결한 예이다. 동일한 자원을 접근하려는 n개의 프로세스가 존재하며, 각 프로세스 i는 P(i)를 수행한다. 프로세스가 공유 자원을 접근하려는 코드 부분이 임계영역으로 정의도니다. 그리고 각 프로세스에서는 임계 영역에 들어가기 직전 semWait(s)를 호출한다. 만일 세마포어 s의 값이 양수가 아니라면, 프로세스는 블록된다. 만일 세마포어 s의 값이 1이라면, 1만큼 감소시킨 후 임계영역에 들어간다. 이제 ㅅ세마포어 s의 값이 더 이상 양수가 아니며, 따라서 다른 프로세스들은 임계영역에 진입할 수 없다.

&nbsp;&nbsp;&nbsp;&nbsp;세마포어는 1로 초기화 된다. 따라서 최로로 semWait를 수행하는 프로세스가 s의 값을 0으로 바꾸고 임계영역에 들어가게 된다. 임계 영역에 들어가고자 하는 다른 프로세스들은 블록되고, s의 값은 1씩 감소된다. 즉, 프로세스들이 임계영역의 진입을 시도할 때마다, s의 값은 하나씩 감소된다. 처음에 임계영역에 들어갔던 프로세스가 빠져나오면, s는 1 증가되고, 블록되어 있던 프로세스들 중에서 하나가 블록 큐에서 나와서 준비 큐로 이동한다. (즉, 블록 상태에서 수행가능 상태로 전이된다.) 이 프로세스가 운영체제에 의해 스케줄되면, 결국 임계영역에 들어가게 된다. 이 예에서 우리는 한 순간에 하나의 프로세스만 임계영역에 들어감을 알 수 있다.

##### 범용 세마포어를 이용한 상호 배제 동작
![os46](https://user-images.githubusercontent.com/31890257/48316331-8c7d4b00-e625-11e8-8780-af79e4aa2d74.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;이 예에서 A, B, C라는 세 개의 프로세스는 lock이라는 이름의 세마포어 변수에 의해 보호되는 공유 자원을 접근하고 있다.
1. 프로세스 A가 semWait(lock)를 실행한다. 세마포어 변수는 1로 초기화 되어 있기 때문에 A는 즉시 임계 영역에 들어갈 수 있다. 이때 세마포어 변수는 0으로 변한다.
2. 프로세스 A가 임계영역에 있는 동안, semWait(lock)를 실행한 프로세스 B와 C는 블록된다.
3. 프로세스 A가 임계영역에서 탈출하고 semSignal(lock)을 수행하면 블록되어있던 프로세스 B가 블록상태에서 깨어나 임계영역에 들어선다.
4. 프로세스 B가 임계영역에서 탈출하게 되면 과정 3에서와 같이 실행되어 블록되어 있던 프로세스 C가 깨어나 임계영역에 들어선다.

#### 세마포어 이용 특성
* 프로세스가 블록될지 여부를 세마포어를 감소시키기 전까지 알 수 없다.
* 단일프로세서 상에서 두 개의 프로세스가 동시에 수행될 때 어떤 프로세스가 즉시 수행될 지 알 수 없다.
* 블록된 프로세스가 존재하는지 알 수 없어 결국 깨어나는 프로세스가 0 또는 1인지 알 수 없다.

#### 세마포어 초기화 값 설정
  * N : N개의 공유자원의 접근제어에 활용
  * 1 : 단일 공유자원의 접근제어에 활용
  * 0 : 사건 발생의 통지(동기화)에 활용

### 생산자/소비자 문제

#### 생산자 소비자 문제 정의
  * 병행 수행되는 다수의 생산자와 소비자 존재
  * 하나 또는 그 이상의 생산자들이 데이터를 생성하여 버퍼에 저장
    * 가득 찬 버퍼에 데이터를 저장할 수 없음
  * 하나의 소비자는 한 번에 하나씩 버퍼에서 데이터를 꺼내 소비
    * 빈 버퍼에서 데이터를 꺼낼 수 없음
  * 생산자들이나 소비자들 중에서 하나만 한 시점에 버퍼에 접근 가능함
  * 병행 수행되는 다수의 생산자와 소비자 존재
  * 생산자들이나 소비자들 간에 또는 생산자와 소비자 간에 버퍼 접근의 상호배제 보장
  * 소비자는 빈 버퍼에서 데이터를 꺼내려 할 때 블록됨
  * 생산자는 빈 버퍼에 데이터를 추가할 때 소비자를 깨움

![os47](https://user-images.githubusercontent.com/31890257/48316332-8d15e180-e625-11e8-8746-6dc73ce630df.JPG)

  >위 그림의 음영 부분은 버퍼에서 유효한 데이터가 차지한 공간을 나타냄

#### 무한 버퍼구조에서 생산자/소비자 작업의 가상코드

![os48](https://user-images.githubusercontent.com/31890257/48316333-8d15e180-e625-11e8-972a-78c159648391.JPG)

소비자 의사 코드의 `while(ture)`문 안의 `while(in<= out)`에서 `in`의 값이 `out` 값보다 작거나 같으면 자료구조 안에 값이 없다는 것을 뜻하며 반대로 크면 자료구조 안에 값이 존재한다는 것을 의미한다. 만약 자료구조 안에 값이 존재하지 않을 경우 소비자는 busy-waiting 상태로 대기한다.

#### 무한 버퍼에서 이진 세마포어를 이용한 해결 방법:부 정확한 버전
![os49](https://user-images.githubusercontent.com/31890257/48316334-8d15e180-e625-11e8-80c4-d4b75efb425c.JPG)

&nbsp;&nbsp;&nbsp;&nbsp; 이번엔 이진 세마포어를 이용하여 생산자/소비자문제를 해결하자. 여기서는 `in`, `out`을 따로 관리하는 대신 변수 `n`을 사용하였다. 변수 `n`은 버퍼에서 유효한 데이터의 수, 즉 `n = in - out`이다. 한편, 세마포어 s는 상호 배제를 보장하기 위하여 사용되며, 세마포어 `delay`는 버퍼가 비어 있을 때 소비자를 블록시키기 위해 사용되었다.

&nbsp;&nbsp;&nbsp;&nbsp;생산자는 데이터를 자유롭게 버퍼에 추가 할 수 있다. 단지 추가하기 전에 상호 배제를 위해 `semWaitB(s)`를 호출하고 추가한 후에 `semSignalB(s)`를 호출하면 된다. 이것이 버퍼에 데이터를 추가할 때 소비자의 버퍼 사용을 방지하는 장치이다. 그리고 생산자는 임계영역 내에 있는 동안 `n`의 값을 증가시킨다. 증가 이후 `n = 1`이 되면, 즉 증가 이전에 `n = 0`이었다면 데이터를 버퍼에 추가하기 바로 전에는 버퍼가 비어 있었다는 것을 의미한다. 따라서 생산자는 소비자에게 버퍼에 데이터가 채워졌다는 사실을 알려주기 위하여 `semWaitB(delay)`를 호출한다. 그러면 소비자는 임계영역으로 진입하여 데이터를 꺼내고 `n`을 감소시킨다. 만일 생산자가 소비자에 비해 먼저 수행될 수 있다면, `n`이 대부분 양수 이기 때문에 소비자가 세마포어 `delay`에서 블록되는 경우는 매우 드물 것이다. 따라서 생산자와 소비자 모두 원할하게 수행된다.

&nbsp;&nbsp;&nbsp;&nbsp;하지만 이 프로그램에는 결함이 있다. 소비자가 버퍼의 데이터를 모두 소진하면 생산자의 새로운 생산이 있을 때 까지 세마포어 `delay`에 대기하여야 한다. 프로그램에서 `if(n == 0) semWaitB(delay)` 문장이 이 역할을 담당한다.

#### 무한 버퍼에서 이진 세마포어를 이용한 문제 해결 방법의 수행 예

![os50](https://user-images.githubusercontent.com/31890257/48316335-8d15e180-e625-11e8-993f-2b95d1171c78.JPG)
>표에서 흰색 영역은 세마포어에 의해 보호되는 임계영역을 나타냄

1. 14번째 줄에서 소비자는 `semWaitB(delay)`를 수행하지 않는다.
2. 소비자는 버퍼에 있는 데이터를 모두 사용하였기 때문에 `n`을 0으로 설정하였지만(8번째 줄), 10번째와 13번째 줄 사이에서 소비자의 `consume()`함수가 실행되는 도중, 즉 `semWaitB(delay)`를 호출하기 전에 (14번째 줄) 생산자가 `n`을 이미 증가시켰다(11번째 줄).  
3. 그 결과 `semSignalB`는 이전의 `semWaitB`와 서로 일치하지 않게 된다. 20번째 줄에서 `n`이 -1인 것은 소비자가 버퍼에서 존재하지 않는 데이터를 소비했다는 것을 뜻한다. 이문제를 해결하기 위해서 조건문을 소비자의 임계영역 내로 옮기는 것을 고려 할 수 있다. 하지만 이것은 교착상태를 일으킬 수 있다(8번째 줄 수행 이후).

#### 무한 버퍼에서 이진 세마포어를 이용한 문제 해결 방법 : 정확한 버전
![os51](https://user-images.githubusercontent.com/31890257/48316336-8dae7800-e625-11e8-9e52-5848a3a88afd.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;위의 이진 세마포어를 이용한 해결 방법은 정확하지 않다는 것을 이제 알게 됬다. 제대로 해결하기 위해 소비자의 임계영역 내에 보조 변수 `m`을 사용한다. 이 변수는 소비자의 임계영역 내에서 설정되며, 그 이후에 사용된다. 문제를 일으킨 `if(n == 0) semWaitB(delay)`의 조건식을 `if(m == 0) semWaitB(delay)`으로 바꾼것이다. 이렇게 되면 비어있는 버퍼 내에서 버퍼를 소비하지 않고 나아가 교착상태도 일으키지 않음을 알 수 있다.

#### 무한 버퍼에서 범용 세마포어를 이용한 해별 방법

이 문제를 보다 깔끔하게 해결하는 방법은 범용 세마포어를 사용하는 것이다.

![os52](https://user-images.githubusercontent.com/31890257/48316337-8dae7800-e625-11e8-8064-c555ee775451.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;이 예에서 변수 `n`은 세마포어이다. 그리고 버퍼에 존재하는 유효한 데이터 개수를 나타낸다. 위 그림에서 프로그램에는 두 개의 세마포어에 대한 연속된 호출이 나타난다. 여기에서 우린 흥미로운 질문을 하나 생각해보자. 만일 생산자 프로그램의 `semSignal(s)`과 `semSignal(n)`이 서로 바뀌어 프로그램 된다면 어떻게 될까? 이것은 세마포어 `s`에 의해 보호되는 임계영역 내부에서 세마포어 `n`에 대한 `semSignal`을 수행하게 된다. 이것이 프로그램 수행에 영향을 줄까? 아니다. 소비자는 두 세마포어를 기다려야 하기 때문에 수행 과정에는 영향이 없다.  
&nbsp;&nbsp;&nbsp;&nbsp;하지만 소비자 프로그램에서 `semWait(n)`과 `semWait(s)`의 연산 순서가 바뀐다면 버퍼가 비어있을 때 소비자가 임계영역에 들어가면 세마포어 `s`를 확보한 채 세마포어 `n`에서 블록된다. 한편 생산자는 세마포어 `s`에 대한 허가를 얻을 수 없어 버퍼에 데이터를 추가하기 위한 임계영역에 진입하지 못한다. 결국 교착상태에 빠지게 된다. 이 예는 세마포어의 미묘한 성질과 올바른 설계의 중요성을 보여주는 좋은 예이다.

#### 환형 큐로 구현한 유한 버퍼에서 문제 정의
&nbsp;&nbsp;&nbsp;&nbsp;지금까지 버퍼의 크기를 무한하다고 가정하고 문제를 풀었다. 이제 버퍼가 유한하다는 현실적인 제한을 추가해보자.

유한한 버퍼에서 문제를 정의하면 다음과 같다.
* 병행 수행되는 다수의 생산자와 소비자가 존재
* 생산자 간에 또는 생산자와 소비자 간에 버퍼 접근의 상호배제 보장
* 생산자는 가득 찬 버퍼에 데이터를 추가하려 할 때 블록됨
* 생산자는 빈 버퍼에 데이터를 추가하려할 때 소비자를 깨움
* 소비자는 빈 버퍼에서 데이터를 꺼내려 할 때 블록됨
* 소비자는 가득 찬 버퍼에서 데이터를 꺼냈을 때 생산자를 깨움

![os53](https://user-images.githubusercontent.com/31890257/48316338-8dae7800-e625-11e8-9b7f-4e5f4d3ef411.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;위 그림은 환형 큐로 구현된 버퍼 구조를 보여준다. 이 구조에서 in과 out 인덱스 위치는 버퍼 크기에 의해 제한된다. 즉 인덱스의 위치가 버퍼 크기보다 커지는 경우 다시 0으로 설정하게 된다.

![os54](https://user-images.githubusercontent.com/31890257/48316339-8dae7800-e625-11e8-9e9c-a6b6887cf31c.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;유한 버퍼를 사용하는 경우, 생산자와 소비자 함수는 다음과 같이 표현될 수 있다. (변수 `in`과 `out`의 초기값은 0이며, `n`은 버퍼의 크기이다.)

![os55](https://user-images.githubusercontent.com/31890257/48316340-8e470e80-e625-11e8-887f-67ae69d1ab46.JPG)

위 코드는 유한 버퍼를 이용한 문제 해결 프로그램이며 `e`는 버퍼에서 빈 공간을 나타낸다.

### 세마포어 구현

* 세마포어 연산, 즉 `semWait`와 `semSignal`은 반드시 원자적으로 구현되어야 한다.
  * 세마포어 변수 접근(전역변수)에 대해 상호배제를 보장하기 위함
  * 연산이 재진입 가능 루틴이 아닌 경우

* 구현 방법
  * Dekker 또는 Perterson 알고리즘을 이용한 구현
  * 하드웨어적인 방법 : 인터럽트 금지를 이용한 구현
  * 펌웨어적인 방법 : Compare-and-Swap 명령어를 이용한 구현

### 세마포어의 문제점

* 세마포어는 상호 배제의 보장과 동기화를 위해 사용되는 강력하고 유연한 프리미티브임
  * `semWait()`와 `semSignal()`이 프로그램 전체에 분산되어 있을 때 프로그램 수행에 어떠한 영향을 미치는지 파악하기 쉽지 않음
  * 특정 자원을 사용하는 모든 프로세스들이 올바르게 프로그램되어야만 그 자원에 대한 올바른 접근이 가능함
