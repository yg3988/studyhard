# 병행성 : 교착상태와 기아상태

## 교착상태 원리

&nbsp;&nbsp;&nbsp;&nbsp;교착상태란 프로세스들의 집합이 더이상 진행을 못하고 영구적으로 블록되어 있는 상태로 시스템 자원에 대한 경쟁 도중에 발생할 수도 있고 프로세스 간 통신 도중에 발생할 수도 있다. 교착상태가 영구적인 이유는 기다리던 사건이 결코 발생하지 않기 때문이다. 다른 병행 프로세스 관리 문제들과는 달리, 모든 교착상태에 적용될 수 있는 효과적인 해결책은 아직 제안되지 않았다.

&nbsp;&nbsp;&nbsp;&nbsp;교착상태는 두 개 이상의 프로세스들이 서로 충돌되는 자원 요구를 할 때 발생한다. 교착상태의 대표적인 예는 교통 교착상태이다.

![os59](https://user-images.githubusercontent.com/31890257/48410864-3de5c300-e783-11e8-9385-a0d6380a9afe.JPG)

교차로의 네 구역(a, b, c, d)은 제어가 필요한 공유 자원이 된다. 일단 각 차들이 직진하려고 한다고 가정하자. 그럼, 사거리 교차로에서 각 차들이 원하는 자원은 다음과 같다.

* 차 1 : 북쪽으로 진행 중. 구역 a, b가 필요
* 차 2 : 서쪽으로 진행 중. 구역 b, c가 필요
* 차 3 : 남쪽으로 진행 중. 구역 c, d가 필요
* 차 4 : 동쪽으로 진행 중. 구역 d, a가 필요

&nbsp;&nbsp;&nbsp;&nbsp;각 차는 필요한 두 개의 구역 중 하나를 차지하고 다른 하나의 구역을 다른 차가 차지하는 경우 더 이상 진행하지 못함.

&nbsp;&nbsp;&nbsp;&nbsp;사거리 교차로에서 흔히 적용되는 규칙은 오른쪽 차 우선 규칙이다. 예를 들어 북쪽으로 직진하려는 차와 서쪽으로 직진하려는 차가 교차로에 진입하려 할 때, 서쪽으로 직진하려는 차는 진행하고 북쪽으로 직진하려는 차는 일단 멈추는 것이다. 이 규칙은 교차로에 두 대 또는 세 대의 차가 있을 때에는 잘 작동한다. 하지만 네 대의 차가 사거리 교차로의 모든 진입로에 동시에 들어오면 이 규칙은 제대로 동작하지 않는다. 규칙을 지키면 모든 차가 더 이상 진입을 못하는 상태, 즉 교착상태가 된다.

&nbsp;&nbsp;&nbsp;&nbsp;프로세스와 자원 관계에서 교착 상태를 살펴보자

![os60](https://user-images.githubusercontent.com/31890257/48410866-3de5c300-e783-11e8-8a53-bcf832711662.JPG)

위 그림은 P와 Q라는 두 개의 프로세스가 A와 B라는 자원을 경쟁적으로 사용하며 수행하는 과정을 보여준다. 이 그림은 결합 진행 다이어 그램이라 불린다. 각 프로세스는 일정 기간동안 두 개의 자원을 동시에 배타적으로 사용해야 한다. 프로세스 P와 Q의 수행을 가상 코드로 살펴보면 다음과 같다.

![os61](https://user-images.githubusercontent.com/31890257/48410869-3de5c300-e783-11e8-8969-66b90ad0c554.JPG)

위 도표에서 x축은 프로세스 P의 진행을 y축은 프로세스 Q의 진행을 나타낸다. 프로세스가 병행 수행되면 진행 경로는 그림 내부의 화살표처럼 원점에서 시작하여 북동쪽 방향으로 움직이는 경로가 된다. 단일 처리기의 경우, 한 시점에 수행되는 프로세스가 하나밖에 없으며 따라서 진행 경로는 수평 또는 수직 방향으로만 움직이게 된다. 즉, 원점에서 출발하여 P가 수행하면 오른쪽 수평 방향으로, Q가 수행하면 위쪽 수직 방향으로 진행한다. 한편, 그림에서 두 프로세스들이 동시에 자원 A를 할당받은 영역은 상향 대각선으로 채워져 있다. 두 프로세스들이 동시에 자원B를 할당 받은 영역은 하향 대각선으로 채워져 있다. 그리고 두 프로세스들이 동시에 두 자원을 모두 할당 받은 영역은 상향 대각선과 하향 대각선이 모두 채워져 있다. 하지만, 프로세스는 자원을 독점적으로 사용하여야 한다. 따라서 상향 또는 하향 대각선으로 채워진 영역은 실제로는 진행경로가 진입할 수 없는 영역이 된다.

&nbsp;&nbsp;&nbsp;&nbsp;도표는 여섯 가지 서로 다른 수행 경로를 보여준다. 이들은 다음과 같이 요약될 수 있다.

1. 프로세스 Q가 자원 B를 획득하고 그 이후에는 다시 자원 A를 획득한다. 수행 완료 이후 프로세스 Q는 두 자원을 반납한다. 이제 프로세스 P가 수행되면 두 자원을 사용할 수 있다.

2. 프로세스 Q가 자원 B를 획득하고 이후 다시 자원 A를 획득한다. 이 때 프로세스 P가 수행된다. 하지만 P는 자원 A의 획득에 실패하고 블록된다. 프로세스 Q가 수행을 완료하고 자원들을 반납한다. 블록되었던 프로세스 P가 깨어나면 두 자원을 사용할 수 있다.

3. 프로세스 Q가 자원 B를 획득하고 프로세스 P가 자원 A를 획득한다. 프로세스 Q는 자원 A의 획득을 시도하다가 블록되고, 프로세스 P는 자원 B의 획득을 시도하다가 블록된다. 그런데 프로세스들이 서로를 기다리며 블록되어 있기 때문에 더이상 진행 될 수 없다. 교착상태가 발생한 것이다.

4. 프로세스 P가 자원 A를 획득하고 프로세스 Q가 자원 B를 획득한다. 프로세스 P는 자원 B의 획득을 시도하다가 블록되고, 프로세스 Q는 자원 A의 획득을 시도하다가 블록된다. 이 경우도 교착상태다.

5. 프로세스 P가 자원 A를 획득하고 그 이후에 다시 자원 B를 획득한다. 이때 프로세스 Q가 수행된다. 하지만 Q는 자원 B의 획득에 실패하고 블록된다. 프로세스 P가 수행을 완료하고 자원을 반납한다.

6. 프로세스 P가 자원 A를 획득하고 그 이후 다시 자원 B를 획득한다. 수행 완료 이후 프로세스 P는 자원을 반납한다. 이제 프로세스 Q가 수행되면 주 자원을 사용할 수 있다.

&nbsp;&nbsp;&nbsp;&nbsp;위 도표에서 회색으로 칠해진 영역을 치명적인 영역이라고하자. 프로세스들의 수행 경로가 치명적인 영역으로 진입하면 교착상태는 피할 수 없다. 치명적인 영역의 존재 여부는 두 프로세스의 로직에 의해 결정된다. 교착상태의 발생 여부는 두 프로세스의 결합 수행 경로가 치명적인 영역으로 진입하는가에 의해 결정된다.

&nbsp;&nbsp;&nbsp;&nbsp;교착상태의 발생은 동적인 프로세스 수행 과정뿐만 아니라 응용의 세부사항에도 영향을 받는다. 예를 들어 프로세스 P가 자원 A와 B를 동시에 사용하지 않는다고 가정해보자.

![os62](https://user-images.githubusercontent.com/31890257/48410870-3de5c300-e783-11e8-8397-78e6c23c461f.JPG)

수정된 프로그램에 대한 프로세스 P와 Q의 진행 경로는 다음과 같다.

![os63](https://user-images.githubusercontent.com/31890257/48410871-3e7e5980-e783-11e8-8fb2-75f28c9eed26.JPG)

그림에서 알수 있듯이 이 시나리오에서는 두 프로세스의 상대적인 수행 속도와 무관하게 교착상태가 발생하지 않는다.


### 재사용 가능한 자원

&nbsp;&nbsp;&nbsp;&nbsp;프로세스가 사용하는 자원은 크게 두 종류로 구분할 수 있따. 하나는 재사용 가능한 자원이고 다른 하나는 소모성 자원이다. 우선 재사용 가능한 자원에 대해서 논의해보자. 재사용 가능한 자원은 프로세스의 사용에 의해 없어지지 않는 자원이다. 따라서 프로세스가 사용한 후 다른 프로세스가 다시 사용할 수 있도록 반납한다. 프로세서, 입출력채널, 주/보조 메모리, 장치, 파일이나 데이터베이스나 세마포어와 같은 자료 구조 등이 재사용 가능한 자원의 대표적인 예이다.

### 소모성 자원

&nbsp;&nbsp;&nbsp;&nbsp;소모성 자원은 생성되었다가 사용된 이후 소멸되는 자원이다. 보통, 소모성 자원에는 개수의 제한이 없다. 블록되지 않은 생산 프로세스는 자원을 몇 개라도 생산할 수 있다. 자원이 소비 프로세스에 의해 사용되면, 그 자원은 사라진다. 소모성 자원의 대표적인 예는 인터럽트, 시그널, 메시지, 입출력 버퍼 내의 정보이다.

### 자원 할당 그래프

&nbsp;&nbsp;&nbsp;&nbsp;자원 할당 그래프는 프로세스와 자원 할당 관계를 표현하는데 유용한 도구로 Holt에 의해 제안되었다. 자원 할당 그래프는 유향 그래프로 자원과 프로세스가 노드가 된다. 일반적으로 자원은 사각형으로 표현하며, 프로세스는 원으로 표현한다. 프로세스에서 자원으로 향한 링크는 프로세스가 그 자원을 원하고 있지만 아직 할당은 되지 않은 상태임을 의미한다.

![os64](https://user-images.githubusercontent.com/31890257/48410873-3e7e5980-e783-11e8-946e-1e87e0aa5e63.JPG)

이 그림에서 자원으로 나타내는 사각형 노드 내부에 점이 있는 것을 알 수 있다. 각 점은 그 자원의 인스턴스를 의미한다. 특정 자원은 가용 개수가 여러 개일 수 있는데, 예를 들어 생산자와 소비자 문제에서 생산자가 세 개의 데이터를 생산했다면, 이 경우 공유 버퍼 자원에서 자원 인스턴수 개수는 3이 된다.

&nbsp;&nbsp;&nbsp;&nbsp;재사용 가능한 자원의 경우, 자원의 점에서 프로세스로 향한 링크는 프로세스가 그자원을 할당하였음을 의미한다. 소모성 자원의 경우, 자원의 점에서 프로세스로 향한 링크는 그 프로세스가 자원의 생산자임을 의미한다.

### 교착상태 조건

##### 필요 조건
1. 상호 배재 조건
  * 한 순간에 한 프로세스만이 자원을 사용하 수 있음
2. 점유대기 조건
  * 자원을 요청하여 기다리는 프로세스가 이미 할당된 자원을 점유하고 있음
3. 비선점 조건
  * 프로세스에 의해 점유된 자원을 다른 프로세스가 강제적으로 빼앗을수 없다. 이는 OS의 자원 관리 정책이다.

##### 충분 조건
4. 환형 대기 조건
  * 프로세스들 간에 닫힌 연결을 이루고, 닫힌 연결에서 블록된 프로세스가 자원을 점유하고 있는데, 이 자원을 체인 내부의 다른 프로세스가 원하며 대기하고 있다. 이는 OS의 정책에 의해 교착상태가 발생한 상태라고 말할 수 있다.

&nbsp;&nbsp;&nbsp;&nbsp;조건 4는 조건 1~3의 결과에 의해 발생한다. 즉, 조건 1~3의 복잡한 상호작용의 결과 해결할 수 없는 환형 대기 상태가 발생하게 되는 것이다. 교착상태의 정의가 바로 해결할 수 없는 환형 대기 상태이다.

&nbsp;&nbsp;&nbsp;&nbsp;교착 상태란 프로세스들의 수행 과정 중에 환형 대기 조건이 발생한 것이다.

| 교착상태 가능 | 교착상태 발생 |
| :------------- | :------------- |
| 상호 배재 조건 | 상호 배재 조건 |
| 점유대기 조건 | 점유대기 조건 |
| 비선점 조건 | 비선점 조건 |
|| 환형 대기 조건|

### 교착상태 해결을 위한 접근 방법

1. 교착상태 예방
  * 교착 상태의 발생 조건 1~4 중에 하나를 시스템에서 호용하지 않는 것이다.
2. 교착상태 회피
  * 현재 자원 할당의 상태에 따라 안전하게 자원할당을 결정하는 것이다. 즉, 자원 할당 요구 시 교착상태가 발생 가능한 상황으로 진행하지 않도록 자원 할당을 결정하는 방법
3. 교착상태 발견 및 회복
  * 자원을 할당 한 후 교착상태가 발생하면 그것을 발견하고 회복하는 방법

## 교착상태 예방
&nbsp;&nbsp;&nbsp;&nbsp;교착상태 예방 전력은 운영체제를 설계할 때 교착상태가 발생할 가능성을 없애는 것이다. 가장 이상적인 방법으로 보이지만, 시스템에 제약을 두는 방법인 것이다. 구체적으로 교착상태가 발생하기 위한 네 가지 필요충분조건 중에 하나를 설계단계에서 배제하는 것이다. 교착 상태 예방 방법은 크게 간접적인 방법과 직접적인 방법으로 구분할 수 있다.

* 간접적인 방법
  * OS 자원 할당 정책에서 상호 배제, 점유 대기, 비선점 조건 중 하나가 일어나지 않도록 함
* 직접적인 방법
  * 시스템에 환형대기 조건이 일어나지 않도록 함

&nbsp;&nbsp;&nbsp;&nbsp;예방의 문제점은 자원 사용과 프로세스 수행에 비효율성을 야기할 수 있다. 여기서 비효율성이란 CPU 이용율/처리율이 줄어드는 것을 뜻한다.

### 상호배제
&nbsp;&nbsp;&nbsp;&nbsp;OS를 설계할 때 상호배제 조건을 없앨 수 는 없다. 상호 배제 조건은 공유 자원의 일관성을 유지하기 위해 반드시 필요하기 때문에, 자원 접근에서 상호배제가 필요하면 운영체제가 이를 지원해 주어야 한다.

### 점유대기

&nbsp;&nbsp;&nbsp;&nbsp;프로세스는 자신이 사용할 모든 자원을 한순간에 요청한다. 만일 모든 자원을 할당받을 수 있으면 계속 수행한다. 반면 하나의 자원이라도 할당받을 수 없으면, 어떠한 자원도 할당 받지 않은채 대기한다. 이러한 방법으로 점유대기 조건을 없앨 수 있다. 모든 자원이 동시에 필요한 응용에는 매우 적합하지만 프로세스는 모든 자원을 할당 받기 위해 오랜 시간 대기할 수 있으며, 할당 받은 자원의 활용률이 낮다. 그리고 미래에 사용될 모든 자원을 미리 알아햐 한다. 때문에 사용될 자원에 대해 과대하게 예상하는 경향이 생긴다.

### 비선점

&nbsp;&nbsp;&nbsp;&nbsp;비선점 조건은 다음과 같은 두 가지 방법으로 없앨 수 있다.
1. 어떤 자원을 점유한 프로세스가 새로운 자원 요청에 실패하면 점유하고 있는 자원들을 반납함
  * 추후 원래 자원과 새로운 자원을 함께 다시 요청함.
2. 한 프로세스에서 다른 프로세스가 점유한 자원을 원하면, OS는 다른 프로세스가 점유한 자원을 강제적으로 빼앗아(선점) 원하는 프로세스에게 할당함.
  * 우선순위 기반 자원 할당 정책에 적용 가능(교착상태 예방)
  * 자원의 상태를 저장하고 복구하기 쉬운 자원(프로세스)에 적용할 수 있음

&nbsp;&nbsp;&nbsp;&nbsp;하지만 프로세스들의 강제적 중단이 자주 일어나 오버헤드가 크다. 강제적으로 자원을 빼앗아 올 경우 프로세스 상태를 저장해야하며 상태를 저장하지 못했을 경우 빼앗긴 프로세스는 다시 처음부터 프로세스를 수행해야 할 수도 있다.

### 환형대기

&nbsp;&nbsp;&nbsp;&nbsp;환형대기 조건은 자원들의 할당 순서를 정하면 없앨 수 있다. 다시말해 OS는 자원들의 할당순서를 미리 설정하여 놓고, 프로세스의 자원 요청 시 정해진 순서에 따라 할당한다.

###### 자원 할당 순서 : A→B인 경우

  * 자원 A, B가 필요할 P<sub>1</sub>, P<sub>2</sub>는 먼저 A를 얻고 난 뒤 B를 요청할 수 있다.

&nbsp;&nbsp;&nbsp;&nbsp;이 방법의 장점은 OS 설계 시점에 문제를 해결했기 때문에 동적 부하가 회피와 비교했을때 확실히 적다. 하지만 자원 사용의 효율성이 낮고 프로세스의 오랜 대기를 야기할 수 있다. 사용될 자원을 미리 모두 알고있어야 하기도 한다.

## 교착상태 회피

&nbsp;&nbsp;&nbsp;&nbsp;교착상태를 해결할 수 있는 또 다른 법인 회피는 예방과는 약간 다른 접근 방법을 사용한다. 예방은 교착상태 발생을 위해 필요한 네 가지 조건 중에 하나를 예방하는 방법이지만 회피는 교착상태 발생 조건 중 상호 배제, 점유대기, 비선점은 허용하되 자원을 할당할 때 교착상태가 발생 가능한 상황으로 진행하지 않도록 고려한다. 다시말해 OS는 프로세스의 현재 자원 할당 요청을 승인하면, 잠재적인 교착상태가 유발되는지를 조사한다. 만일 교착상태를 발생시킬 가능성이 있다면 자원을 할당하지 않는다. 그래서 회피 방법은 현재 자원의 가용 개수와 프로세스의 자원 요구량을 미리 알고 있어야 한다.

&nbsp;&nbsp;&nbsp;&nbsp;회프를 위한 2가지 접근법이 있다. 하나는 프로세스 시작 거부, 다른 하나는 자원 할당 거부이다. 프로세스 시작 거부는 프로세스가 시작하려 할 때 그 프로세스가 수행 중 필요한 모든 자원요구량이 교착상태의 가능성이 있으면, 프로세스를 시작시키지 않는다. 자원 할당 거부에 경우 수행 중인 프로세스가 요구하는 추가적인 자원 할당의 승인이 잠재적으로 교착상태를 발생시킬 수 있으면, 그 자원을 할당하지 않는다.

### 프로세스 시작 거부
n개의 프로세스들과 m개의 다른 유형에 자원이 있다고 가정하자.

![os65](https://user-images.githubusercontent.com/31890257/48410874-3e7e5980-e783-11e8-9cc3-e73214386fda.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;행렬 C와 A는 프로세스가 요구하고 있는 자원과 현재 프로세스가 점유하고 잇는 자원의 개수를 나타낸다. 이때  각 행은 각 프로세스에 대응된다. 교착상태 회피를 적용하기 위해서 운영체제는 프로세스 수행 전에 이 정보들을 미리 알고 있어야 한다. 이 때 다음과 같은 관계식을 유도할 수 있다.

![os66](https://user-images.githubusercontent.com/31890257/48410875-3f16f000-e783-11e8-9cdd-9d1ff669e9f0.JPG)
* 모든 자원은 이용 가능하거나 할당 되어있다.

![os67](https://user-images.githubusercontent.com/31890257/48410876-3f16f000-e783-11e8-9182-ac6d5044e966.jpg)
* 각 프로세스는 시스템 내의 전체 자원보다 더 많은 개수를 요구 할 수 없다.

![os68](https://user-images.githubusercontent.com/31890257/48410877-3f16f000-e783-11e8-88ef-5daa6fa1f629.jpg)
* 프로세스는 자신이 요구한 자원보다 더 많은 개수의 자원을 할당 받을 수 없다.

&nbsp;&nbsp;&nbsp;&nbsp; 모든 프로세스들이 요구한 자원 개수가 전체 자원보다 적으면 교착 상태가 발생하지 않음을 알 수 있다. 따라서 교착상태 회피를 위한 프로세스 시작 거부 방법은 다음의 식을 만족할 때 새로운 프로세스의 시작을 허가한다.

![os69](https://user-images.githubusercontent.com/31890257/48410878-3faf8680-e783-11e8-98ba-00080454582e.JPG)

위 식의 좌변의 R은 총 자원량을 의미하고 우변의 첫 항 C는 프로세스 P<sub>(n+1)</sub>의 자원 요구량, 두번째 항은 실행되고 있는 모든 프로세스들이 요구하는 자원의 개수를 나타낸다.

&nbsp;&nbsp;&nbsp;&nbsp;결국 새로운 프로세스와 기존의 프로세스들이 요구하는 자원의 개수가 그 자원의 전체 개수보다 적을 경우에 수행을 허용하는 것이다. 이 정책은 최악의 경우, 즉 모든 프로세스들이 동시에 최대 자원을 요구하여 사용함을 가정하기 때문에 비효율적이다.

### 자원 할당 거부

이 방법은 65년 Dijkstra가 제안한 방법으로 은행원 알고리즘이라고 불린다. 프로세스가 어떤 자원을 요구했을 때, 이 자원을 프로세스에 할당하여 교착상태를 야기할 수 있다면 자원을 할당하지 않는다.

&nbsp;&nbsp;&nbsp;&nbsp;은행원 알고리즘에선 상태라는 개념이 중요하다. 때문에 우선 이 두 개념에 대해서 알아야한다. 그 전에 시스템에 고정된 수의 프로세스와 자원이 존재한다고 가정해 보자. 프로세스는 수행 중에 임의의 자원을 할당받아 사용한다. 시스템의 상태(state)란 프로세스들이 자원을 요구하고 할당받은 관계(A)를 나타낸다. 즉, 시스템의 상태란 위에서 정의한 2개의 벡터와 행렬, 즉 자원, 가용이라는 벡터(R, V)와 요구와 할당(C, A)로 표현된다.

&nbsp;&nbsp;&nbsp;&nbsp;시스템의 상태는 안전한 상태와 불안전한 상태로 구분되고 이때 안전한 상태란 교착상태가 발생하지 않도록 적오도 하나의 프로세스에게 자원을 할당할 수 있는 진행 경로가 존재함을 의미한다. 반면에 불안전한 상태는 그러한 진행 경로가 없는 상태이다.

&nbsp;&nbsp;&nbsp;&nbsp;이 때 프로세스에게 자원을 할당할 때 교착상태의 발생 가능성이 있는지 여부를 동적으로 판단한다. 판단 결과 교착상태의 가능성이 없으면 자원을 할당한다. 다른 말로 안전한 상태를 계속 유지할 수 있다면 자원을 할당하는 것이다. 때문에 각 프로세스들이 필요한 자원들을 미리 운영체제에게 알려야주어야 한다.

###### 안전한 상태 예

세 개의 자원 R1, R2, R3과 네 개의 프로세스 P1, P2, P3, P4가 동작하는 시스템이 있다고 하자.

![os70](https://user-images.githubusercontent.com/31890257/48410880-3faf8680-e783-11e8-96ab-4a9b5a905654.JPG)

(a)는 시스템의 초기 상태로 시스템에 존재하는 자원 R1, R2, R3의 전체 개수는 9, 3, 6이다. 현재 가용가능한 자원 개수는 각각 0, 1, 1이다.(a)는 완전한 상태인가? 다른 말로, 네 개의 프로세스들 중에 수행을 완료할 수 있는 프로세스가 존재하는가? 결국 가용 자원의 개수가 현재 프로세스가 요구하고 있는 자원의 개수(전체 요구 개수 - 할당 개수)보다 크면 그 프로세스는 수행을 완료할 수 있다.

![os71](https://user-images.githubusercontent.com/31890257/48410881-3faf8680-e783-11e8-9415-458cb995ea90.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;(a)에서 프로세스 P1은 R1, R2, R3을 각각 2, 2, 2개 더 요구하고 있다. 하지만 현재 남은 자원 개수는 각각 0, 1, 1이므로 P1은 수행을 완료할 수 없다. 반면 P2는 R1, R2, R3을 각각 0, 0, 1개 더 요구하고 있다. 이 요구는 남은 가용 자원으로 서비스 가능하다. 따라서 P2는 수행을 완료할 수 있으며, 완료하면 자신이 점유하던 자원을 모두 반남하게 된다.  
&nbsp;&nbsp;&nbsp;&nbsp;결국 자원 R1, R2, R3의 가용 자원이 6, 2, 3이 되는 것이다. 이 상태는 (b)에 나타나 있다. 이제 가용 자원을 P1에게 할당해 주면 P1도 수행을 완료할 수 있다. 그리고 자원을 반납한다(c). 그 이후 가용 자원을 P3에게 할당해 주면 P3도 수행을 완료할 수 있고, 자원을 반납하면 시스템은 (d) 상태가 된다. 같은 방법으로 P4도 완료할 수 있으며, 결국 모든 프로세스들이 수행을 완료할 수 있다. 따라서 (a)는 완전한 상태이다.

&nbsp;&nbsp;&nbsp;&nbsp;위 예에서 우리는 자원을 할당할 때 안전한 상태를 계속 유지할 수 있으면 교착상태가 발생하지 않음을 알 수 있다. 즉 프로세스가 자원 할당을 요청했을 때, 이 자원 할당 결과가 시스템의 상태를 계속 안전한 상태로 유지할 수 있는지 파악한다. 만일 그렇다면 자원 할당을 허용하고, 그렇지 않다면 자원 할당을 거부하는 것이다.

###### 불안전한 상태 예

![os72](https://user-images.githubusercontent.com/31890257/48410883-3faf8680-e783-11e8-95db-ae1100f2e8b2.JPG)

위 그림의 (a)는 초기상태이다. 초기상태에서 프로세스 P2가 자원 R1과 R3을 하나씩 더 할당받았다고 가정해보자. 그럼 시스템의 상태는 안전한 상태의 (a)로 되고, 안전한 상태, 즉 모든 프로세스가 수행을 완료할 수 잇는 자원할당 방법이 존재하는 상태이다. 따라서 위 그림 (a)은 안전한 상태이다.  
&nbsp;&nbsp;&nbsp;&nbsp;하지만 다른 시나리오를 생각해보자. 그림(a)에서 프로세스 P1이 자원 R1과 R3을 하나씩 더 할당받았다고 가정해보자 그럼 시스템의 상태가 그림 (b)로 되고 (b)는 불안전한 상태, 즉 어떠한 프로세스라도 자신의 자원 요구를 모두 만족할 수 없으며 결국 수행을 완료하지 못하는 상태가 된다. 따라서 (a)에서 (b)의 상태로 전이시키는 자원 할당은 시스템을 안전한 상태에서 불안전한 상태로 전이시키며,자원 할당 거부 방법은 이러한 전이를 허용하지 않는 것이다.

&nbsp;&nbsp;&nbsp;&nbsp;자원 할당 거부 방법은 자원 할당을 요구할 때 교착상태가 발생할 가능성이 있는지 여부를 동적으로 판단한다. 또, 만약 안전 상태라면 그 요구를 허용하고, 안전하지 않다면 요구를 허용하는 것이 안전할 때까지 그 프로세스를 블록시킨다. 그리고 많은 사람들이 헷갈려 하는 것 중에 하나인 '안전하지 않은 상태'라는 것은 실제 교착상태가 발생한 것이 아니라 그 가능성을 가졌다는 의미이다.

&nbsp;&nbsp;&nbsp;&nbsp;교착상태 회피는 교착상태 예방에 비해 자원 할당이 더 자유롭다. 따라서 시스템에서 자원 효율이 높아진다. 또한 교착상태 발견에 비해 자원을 선점하고 프로세스 수행의 롤백이 필요 없다는 장점이 있다. 하지만, 단점으로 네 가지가 있다.
1. 각 프로세스는 자신의 최대 자원 요구량을 미리 명시해야한다.
2. 프로세스들 간에 수행 순서 종속 관계가 없어야 한다.
3. 할당할 자원의 개수가 고정되어야 한다
4. 자원을 선점한 채 종료하는 프로세스는 없어야 한다.

### 교착상태 발견

교착상태 예방은 교착상태가 발생하지 않도록 자원들에 대한 접근과 프로세스의 수행에 제한을 둔다. 하지만 교착상태 발견 전략은 자원 접근데 대한 제한이나 프로세스의 행위에 제한을 두지 않는다. 할당이 가능한 상황이면 항상 프로세스에게 할당을 한다. 단 교착상태 발견 전략은 주기적으로 시스템에 환형대기 조건이 발생하였는지 검사하고, 발생했다면 해결한다.

#### 교착상태 발견 알고리즘

알고리즘은 자원 할당이 요구될 때마다 매번 수행될 수도 있고, 주기적으로 가끔 수행할 수도 있다. 자원할당이 요구될 때마다 매번 수행되면 교착상태를 빠른 시점에 발견할수 있으며 시스템의 상태가 점진적으로 변하기 때문에 발견 알고리즘도 간단해 진다는 장점이 있다. 하지만 잦은 검사로 인해 오버헤드가 크다는 단점이 있다. 주기적으로 수행하는 경우엔 시스템의 처리율 및 프로세서 이용율이 저하디며 다중 환형대기와 연관되어 알고리즘이 복잡하다.

&nbsp;&nbsp;&nbsp;&nbsp;교착상태 발견을 위해 흔히 사용되는 알고리즘은 완료될 프로세스들의 모든 가능한 진행을 고려하여 교착상태를 발견한다. 이 알고리즘은 할당 매트릭스와 가용 벡터를 사용한다. 한편, 새로운 매트릭스를 정의하여 사용하는데 그것이 요청 매트릭스이다. Q<sub>ij</sub>는 프로세스 i에 의해 요청된 자원 j의 개수를 의미한다. 본 알고리즘에 사용되는 벡터와 매트릭스를 간략히 설명하자면 다음과 같다.

* 자원 벡터(R) : 시스템에 존재하는 자원의 전체 개수
* 가용 벡터(V) : 현재 사용 가능한 자원의 개수
* 할당 행렬(A) : 프로세스가 할당 받아 점유하고 있는 자원의 개수
* 요청 행렬(Q) : 프로세스가 요청한 자원의 개수

알고리즘은 가용 자원으로 완료될 수 있는 프로세스를 발견하고, 다음과 같은 순서로 동작한다.

1. 할당 행렬(A)에서 행의 값이 모두 0인 프로세스를 우선 표시한다.
2. 현재 사용 가능한 자원의 개수(V)를 임시 벡터 W의 초기값으로 설정한다.
3. 표시되지 않은 프로세스들 중에서 요청 행렬 Q의 행의 값이 W보다 작거나 같은 프로세스를 찾아 표시한다(1≤k≤m인 모든 k에 대해서 Q<sub>ik</sub>≤W<sub>ik</sub>가 성립). 만약 이러한 프로세스가 없으면 알고리즘을 종료한다.
4. 단계 3의 조건을 만족하는 행 i를 Q에서 찾으면, A<sub>i</sub>의 행을 W에 더한다(W<sub>k</sub>=W<sub>k</sub>+A<sub>ik</sub>,1≤k≤m). 단계 3을 수행한다.

  * 알고리즘이 종료된 이후에 되지 않은 프로세스가 존재한다면 그 프로세스들에서 교착상태가 발생한 것이다.

&nbsp;&nbsp;&nbsp;&nbsp;교착상태 발견 알고리즘은 프로세스 시작을 지연시키지 않으므로 많은 병행성을 허용하는 장점이 있지만 선점에 의한 손실과 잦은 검사로 인한 높은 오버헤드를 발생시킨다.

#### 교착상태 회복 알고리즘

1. 교착상태에 포함되어 있는 모든 프로세스를 종료시킴
2. 교착상태에 포함되어 있는 각 프로세ㅅ를 이전의 검사점으로 되돌린 후 모든 프로세스를 다시 수행시킴
3. 교착상태가 없어질 때까지 교착상태에 포함되어 있는 프로세스들을 하나씩 종료시킴
4. 교착상태가 없어질 때까지 교착상태에 포함되어있는 자원을 하나씩 선점시킴

종료시킬 프로세스의 선택 기준
  * 현재까지 사용한 프로세서 시간이 가장 적은 프로세스부터
  * 현재까지 생산한 출력량이 가장 적은 프로세스부터
  * 이후 남은 수행시간이 가장 긴 프로세스부터
  * 할당 받은 자원이 가장 적은 프로세스부터
  * 우선순위가 낮은 프로세스부터
