# 쓰레드

## 프로세스와 스레드

&nbsp;&nbsp;&nbsp;&nbsp;프로세스란 수행 중인 프로세스, 컴퓨터 상에서 수행 중인 프로그램의 인스턴스, 프로세서에 할당되어 수행될 수 있는 개채, 명령어들의 순차 수행, 현재 상태, 연계된 시스템 자원 등에 의해 특징지어지는 활동 단위로 전 챕터에서 정의했다. 프로세스는 2 가지 특성을 가지고 있다.  
1. 자원 소유 특성 : OS로부터 필요한 자원(주기억장치, I/O장치, 보조기억장치)를 할당 받는다.  
2. 스케줄링/수행 특성 : 프로세스는 스케줄되고 디스패치되는 개체이다.  

오늘날 OS는 이들 특성을 독립적으로 취급한다. 두 가지의 특성을 구별하기 위해서 아래와 같이 말한다.

- 자원 소유권의 단위 : 프로세스, 태스크
- 디스패칭의 단위 : 쓰레드, 경량 프로세스

##### 프로세스

&nbsp;&nbsp;&nbsp;&nbsp;프로세스는 자원 소유 단위로 주소공간, 프로그램 코드, 전역변수, 힙, 스택 OS 자원들을 소유함을 뜻한다.

##### 쓰레드

&nbsp;&nbsp;&nbsp;&nbsp;쓰레드는 스케줄링, 디스패치의 단위로 하나의 프로세스 내에 단일 순차적 실행 스트림, 하나의 프로세스 내의 다른 쓰레드들과 소유 자원들을 공유한다. PC, SP(Stack Pointer), 레지스터들, Stack에 대한 단위이다.

##### PCB 관점
![os21](https://user-images.githubusercontent.com/31890257/48311536-87e47280-e5e4-11e8-8d42-4e50f64632f0.JPG)

### 멀티쓰레딩

&nbsp;&nbsp;&nbsp;&nbsp;멀티쓰레딩이란 운영체제가, 하나의 프로세스 내에서 수행되는 여러 의 쓰레드를 지원하는 기능을 말한다.

![os22](https://user-images.githubusercontent.com/31890257/48311537-887d0900-e5e4-11e8-9378-2b514962f4c8.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;멀티쓰레드 환경에서 프로세스는 보호의 단위와 자원할당의 단위로 정의된다. 다음은 프로세스와 연계된 것들이다.

* 프로세스의 이미지를 유지하는 가상주소 공간
* 다음에 대한 보호 접근
  * 프로세서
  * IPC(Inter Porcess Communication)를 위한 정보
  * 파일
  * 입출력 자원(장치, 채널)

&nbsp;&nbsp;&nbsp;&nbsp;멀티쓰레딩 환경에서 쓰레드는 디스패칭의 단위이다. 각 쓰레드는 다음 사항들을 포함한다.

* 쓰레드 수행 상태
* 수행 중이 아닐 때 저장되는 쓰레드 문맥
* 수행 스택
* 지역 변수 저장을 위한 어떤 정적 저장소
* 프로세스에 할당된 모든 자원 접근

![os23](https://user-images.githubusercontent.com/31890257/48311538-887d0900-e5e4-11e8-9bad-b01931707add.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;위 그림은 프로세스 관리의 관점에서 쓰레드와 프로세스의 차이점을 보여준다. 단일 쓰레드 프로세스 모델에서, 프로세스는 PCB, 사용자 주소 공간, 사용자 스택과 커널 스택 등으로 표현 된다. 스택은 프로세스 수행 중에 함수 호출/복귀 행위를 관리한다. 멀티쓰레드 호나경에서도 프로세스와 관련되어 하나의 PCB와 사용자 주소공간이 있다. 그러나 단일 쓰레드 모델과 달리 멀티쓰레드 환경에서는, 각 쓰레드마다 별도의 스택이 있고, 또한 레지스터 값, 우선순위, 그 외의 쓰레드 관련 상태 정보를 포함하고 있는 별도의 제어블록이 있다.

&nbsp;&nbsp;&nbsp;&nbsp;따라서 프로세스 내의 모든 쓰레드들은 그 프로세스의 상태오 ㅏ자원을 공유한다. 그 쓰레드들은 같은 주소 공간에 존재하며, 동일한 데이터를 접근한다. 프로세스 내의 한 쓰레드가 메모리에 있는 데이터 항목을 변경했을 경우, 다른 쓰레드도 그 데이터 항목에 접근하여 그 결과를 확인할 수 있다. 만일, 하나의 쓰레드가 읽기 권한을 가지고 파일을 개방하면, 같은 프로스세스에 있는 다른 쓰레드 들고 그 파일을 읽을 수 있다.

쓰레드의 장점을 다음과 같이 설명할 수 있다.

1. 새로운 프로세스를 생성하는 시간보다 기존 프로세스 내에서 새로운 쓰레드 생성하는 시간이 더 짧다.
2. 프로세스 종료시간보다 쓰레드 종료시간이 더 짧다.
3. 프로세스들 간 교환보다 같은 프로세스에 있는 두 쓰레드 간 교환이 효효율적이다.
4. 서로 다른 수행 프로그램 간 통신에서도 효율적이다.

&nbsp;&nbsp;&nbsp;&nbsp;연관된 수행단위의 집합으로 구현되어야 하는 응용이나 기능이 있다면, 독립적인 프로세스가 아닌 쓰레드의 모음으로 구현하는 것이 훨씬 효율적이다.

&nbsp;&nbsp;&nbsp;&nbsp;단일 사용자 멀티프로세싱 시스템에서 쓰레드 사용의 예

* 전면과 후면 작업
* 비동기 처리
* 빠른 수행
* 모듈 프로그램 구조

&nbsp;&nbsp;&nbsp;&nbsp;쓰레드를 지원하는 운영체제에서는 스케줄링과 디스패칭이 쓰레드를 기초로 하여 이루어진다. 따라서 수행에 관련된 대부분의 상태 정보가 쓰레드 수준의 자료구조에 의해 유지된다. 그러나 몇몇 작업들은 프로세스 내의 모든 쓰레드에게 영향을 미치며, 운영체제는 이를 프로세스 수준에서 관리해야 한다. 예를 들어 한 프로세스가 보류 상태로 전환되어 스왑 아웃을 한다면 프로세스 내 모든 쓰레드도 동시에 보류 상태로 된다. 이와 유사하게, 한 프로세스가 종료되면 그 프로세스 내의 모든 쓰레드도 종료된다.

### 쓰레드 기능
&nbsp;&nbsp;&nbsp;&nbsp;프로세스처럼 쓰레드도 수행 상태를 가지며 서로 동기화될 수 있다.
#### 쓰레드 상태

&nbsp;&nbsp;&nbsp;&nbsp;프로세스 상태와 같이, 각 쓰레드의 주요 상태에는 수행과 준비 그리고 블록이 있다. 일반적으로 보류 상태는 프로세스 수준의 개념이기 때문에 쓰레드와 연관시키는 것은 의미가 없다.

![os24](https://user-images.githubusercontent.com/31890257/48311539-887d0900-e5e4-11e8-8583-40d9c1512fd2.JPG)

* 생성 : 새로운 프로세스 생성되면 쓰레드도 함께 생성, 이 쓰레드는 프로세스 내에서 다른 쓰레드 생성 가능, 생성된 쓰레드를 위해 명령 포인터와 인자들을 제공한다. 새로운 스레드는 자신의 레지스터 문맥과 스택 공간을 가지며 Ready Queue에 위치된다.

* 블록 : 이벤트가 발생할 때까지 기다리는 쓰레드는 블록된다. 이때, 자신의 사용자 레지스터, 프로그램 카운터, 스택포인터를 저장한다.

* 비블록 : 기다리고 있던 이벤트가 발생할 때 쓰레드는 Block Queue에서 RReady Queue에로 이동한다.

* 종료 : 쓰레드가 작업을 완료하면 레지스터 문맥과 스택이 해제된다.

&nbsp;&nbsp;&nbsp;&nbsp;여기서 주요 논점은 한 쓰레드의 블록이 전체 프로세스를 블록시키는지의 여부이다. 프로세스 내의 한 쓰레드가 블록되면, 같은 프로세스 내의 다른 쓰레드가 준비상태에 있더라도 수행 상태로 전이할 수 없는가 하는 문제이다. 만일 하나의 쓰레드가 전체 프로세스를 블록시킨다면 쓰레드가 지닌 장점과 유연성이 사라지게 된다.

#### 쓰레드 동기화

&nbsp;&nbsp;&nbsp;&nbsp;프로세스 내의 모든 쓰레드는 주소공간과 열린 파일과 같은 자원을 공유한다. 하나의 쓰레드에 의한 자원의 변경은 같은 프로세스 내에 존재하는 모든 쓰레드의 환경에 영향을 미친다. 따라서 쓰레드들이 서로 간섭하지 않도록, 또는 자료 구조를 손상시키지 않도록 쓰레드들의 행위를 동기화 하는 것이 필요하다.

## 쓰레드의 유형

### 사용자 수준 쓰레드와 커널 수준 쓰레드
쓰레드 구현에는 사용자 수준 쓰레드(User Level Thread)와 커널 수준 쓰레드(Kernel Level Thread)의 두 가지 범주가 있다.

#### ULT(User-Level Thread)

* 응용이 쓰레드 라이브러리를 통해 모든 쓰레드 관리를 수행함
  * 쓰레드 생성, 제거, 쓰레드간 메세지 및 데이터 전달, 쓰레드 스케쥴링(flexble), 쓰레드 문맥 저장 및 복구 수행

* 커널은 쓰레드의 존재를 알지 못함
* 커널은 프로세스 스케줄링, 프로세스 문맥 유지함


![os25](https://user-images.githubusercontent.com/31890257/48311540-887d0900-e5e4-11e8-9670-3078714231a5.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;새로운 쓰레드 생성, 쓰레드 스케줄링, 문맥교환 등의 모든 작업들은 사용자 공간과 단일 프로세스 내에서 이루어진다. 커널은 이러한 작업을 전혀 알지 못한다. 커널은 계속 프로세스 단위로 스케줄하며, 그 프로세스에게 어떤 수행 상태를 할당한다. 쓰레드 스케줄링과 프로세스 스케줄링에 간의 관계를 명확히 하기 위해 아래의 예로 설명한다. 프로세스 B가 그 자신의 쓰레드 2에서 수행중이라고하자. 프로세스 B와 그 ULT 2개의 상태가 그림 (a)에 나타나 있다. 발생 가능한 상황은 다음 중 하나이다.

![os26](https://user-images.githubusercontent.com/31890257/48311541-89159f80-e5e4-11e8-908e-78973f64f004.JPG)

1. 쓰레드 2에서 수행 중인 응용이 B를 블록시키는 시스템 호출(입출력 호출)을 수행한다. 이때 제어는 커널로 넘어가게 된다. 커널은 입출력 작업을 시작하고, 프로세스 B를 블록상태에 놓은 다음, 다른 프로세스로 교환한다. 한편 쓰레드 라이브러리에 의해 관리되는 자료구조에 의해 프로세스 B의 쓰레드 2는 여전히 수행 상태에 있다. 쓰레드 2가 프로세서 상에서 수행되지는 않기 때문에 실제로는 수행 중이지 않지만, 쓰레드 라이브러리에 의해 수행 상태에 있는 것으로 인식되는 것이다. 이에 대응하는 상태 전이도가 (b)에 나타나 있다.
2. 클록 인터럽트로 인해 제어가 커널로 넘어가고, 커널은 현재 수행 중인 프로세스-B가 자신의 시간 할당량을 다 소모했다고 판정한다. 커널은 프로세스 B를 준비 상태로 놓고 다른 프로세스로 교환한다. 한편 쓰레드 라이브러리가 관리하는 자료구조에 의하면 프로세스 B의 쓰레드 2는 여전히 수행상태에 있다. 이에 대응하는 상태 전이도가 (c)에 나타나있다.
3. 쓰레드 2는 프로세스 B의 쓰레드 1에 의해 수행될 어떤 연산을 필요로 하는 지점에 도달하면 블록 상태에 들어가며, 쓰레드 1이 준비 상태에서 수행 상태로 전이된다. 프로세스 B는 여전히 수행 상태에 있다 이에 대응하는 상태 전이도가 (d)에 나타나 있다.

&nbsp;&nbsp;&nbsp;&nbsp;프로세스는 쓰레드 라이브러리의 코드를 수행하는 동안, 시간 할당량을 다소모하면 인터럽트될 수 있으며, 또한 더 높은 우선 순위를 가진 프로세스에 의해 선점되는 경우에도 인터럽트될 수 있음을 유의해야 한다. 따라서 어떤 프로세스는 한 쓰레드에서 다른 쓰레드로 쓰레드 교환이 발생하는 도중에 인터럽트될 수도 있다. 이 프로세스가 재개되면 쓰레드 라이브러리에서 수행이 계속되며, 이 때 쓰레드 라이브러리는 쓰레드 교환을 완료하고 그 프로세스 내의 새로운 쓰레드에게 제어를 넘기게 된다.

&nbsp;&nbsp;&nbsp;&nbsp;KLT 대신 ULT를 사용하면 장점이 존재한다.

* 스레드 교환에 커널 모드의 권한이 요구되지 않아 속도가 빠르다.
* 스케줄링 정책을 응용에 맞게 구성 가능하다.
* 커널 변경이 필요 없어 어떤 OS에도 적용이 가능하다.

&nbsp;&nbsp;&nbsp;&nbsp;하지만 이러한 장점이 있는 만큼 두 가지 단점도 있다.

* 한 쓰레드의 시스템 호출(Block형)은 같은 프로세스 내에 있는 모든 쓰레드를 블록시킨다.
  * 자켓팅이라고 불리는 기술을 사용하여 Block형 시스템 호출을 Nonblock형 시스템 호출로 변환한다. 그러면 위 문제를 해결 할 수 있다.
* 멀티프로세서(또는 멀티 코어)의 장점을 활용할 수 없다.
  * 유저레벨 쓰레드를 몰라 코어 할당을 못한다.
  * 멀티 쓰레드 대신 멀티프로세스로 프로그램을 작성함으로써 문제를 해결할 수 있다. 하지만 쓰레드의 중요한 장점을 살리지 못한다. 즉, 프로세스 교환을 함으로써 교환마다 오버헤드를 발생시킨다.

#### KLT(Kernel-Level Thread)

&nbsp;&nbsp;&nbsp;&nbsp;KLT 구현에서는 쓰레드 관리와 관련된 모든 작업이 커널에 의해 이루어진다. 응용 영역에는 쓰레드 관리를 위한 코드가 없고, 단순히 커널 쓰레드 기능에 대한 API가 있다. 이 API를 통해 쓰레드 생성 및 종료를 요청한다. Windows가 이러한 예이다.

![os27](https://user-images.githubusercontent.com/31890257/48311542-89159f80-e5e4-11e8-8697-cf84b51ca653.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;커널은 전체 프로세스에 대한 문맥 정보 및 각 프로세스 내 쓰레드에 대한 문맥 정보를 유지한다. 커널에 의한 스케줄링은 쓰레드를 기반으로 해서 이루어진다. 이러한 접근 방법을 사용하여 ULT의 주된 두 가지 단점을 극복하였다. 첫째, 커널은 여러 처리기에서 같은 프로세스 내의 여러 쓰레드를 동시에 스케줄할 수 있다. 둘째, 한 프로세스의 쓰레드가 블록되면 커널은 같은 프로세스에서 다른 쓰레드를 스케줄할 수 있다. KLT의 다른 장점은 커널 루틴 자체가 멀티쓰레드로 구성될수 있다는 것이다.

&nbsp;&nbsp;&nbsp;&nbsp;ULT와 비교할 때 KLT의 주된 단점은 같은 프로세스 내의 한 쓰레드에서 다른 쓰레드로 제어넘길 때, 커널로의 모드 전환이 필요하다는 것이다. 모드 전환으로 인한 오버헤드를 알아보기 위해, UNIX계열 단일 프로세서인 VAX 컴퓨터에서 실험한 결과가 바로 아래 표이다.

![os28](https://user-images.githubusercontent.com/31890257/48311543-89159f80-e5e4-11e8-9754-0ce29452f515.JPG)

#### 결합된 접근 방법(Combined Approaches)

어떤 운영체제는 ULT와 KLT 구현이 결합된 형태를 제공한다. 결합된 방법을 적용하는 시스템에서 쓰레드 생성은 완전히 사용자 공간에서 이루어지며, 한 응용 내의 쓰레드들에 대한 스케줄링 및 동기화도 대부분 사용자 공간에서 이루어진다. 한 응용의 ULT들은 그 보다 적거나 같은 수의 KLT에 사상된다. 프로그래머는 최상의 결과를 당성하기 위해 특정 응용이나 처리기를 위한 KLT의 수를 조절할 수 있다.

![os29](https://user-images.githubusercontent.com/31890257/48311544-89ae3600-e5e4-11e8-85d7-2c7101295003.JPG)

&nbsp;&nbsp;&nbsp;&nbsp;결합된 접근 방법에서는 한 응용의 쓰레드들이 다수의 처리기에서 병렬로 수행될 수 있고, 블록형 시스템 호출이 전체 프로세스를 블록시키지 않는다. 따라서 적절히 설계될 경우, 단점을 최소화하면서 순수 ULT 및 KLT 방식의 장점을 모두 살릴 수 있다.

Solaris 2가 이 접근 방법을 이용하는데 현재는 ULT/KLT 관계를 1-대-1로 제한하고 있다.


#### 쓰레드와 프로세스 간의 관계
![os30](https://user-images.githubusercontent.com/31890257/48311545-89ae3600-e5e4-11e8-95dc-ffc5a7babbdc.JPG)

## 멀티코어와 멀티쓰레딩

### 멀티코어 상에서의 SW 성능

멀티코어 구조의 잠재적인 성능 향상은 응용이 이용 가능한 병렬 자원을 효율적으로 이용할 수 있는 능력에 영향을 받는다. 먼저 멀티코어 시스템 상에서 수행되는 단일 응용에 대해 살펴본다.

##### Amdahl의 법칙

* 시스템의 일부가 개선될 때 전체 시스템에서 어느 정도 성능 개선이 기대될 수 있는지를 나타냄

![os31](https://user-images.githubusercontent.com/31890257/48311546-89ae3600-e5e4-11e8-91ad-6580ac0c6fd1.JPG)

f : SW 전체 대비 개선된 부분 비율  
N : HW 속도 향상이 일어난 정도

##### Gustafson의 법칙

* 대규모의 반복적인 작업을 한 대의 시스템에서 처리할 수 있는 양만큼 나눈 후 시스템 수를 늘려 나누어 처리하면 성능향상은 프로세서 개수의 스케일에 비례함

>성능향상 = a + P(1 - a) = P - a(P - 1)   
>a : 순차처리 비율&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P : 프로세서 개수

&nbsp;&nbsp;&nbsp;&nbsp;멀티코어 시스템은 데이터베이스 관리 시스템과 응용에 효과적으로 사용될 수 있는 한 분야이다. 전형적으로 서버들은 다수의 상대적으로 독립적인 트랜잭션이 병렬처리되기 때문에 많은 종류의 서버들도 병렬 멀티코어 구조를 효과적으로 이용할 수 있다.
