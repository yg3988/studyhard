# 프로세스 기술과 제어

## 프로세스란?

운영체제가 응용 수행을 관리함에 있어 다음을 지원한다.
- 여러 응용들이 자원들을 이용할 수 있게 한다.
- 여러 응용들 사이에 물리적인 처리기를 교체 할당하여 모든 응용들이 병행 진행되는 것처럼 보이게 한다.
- 처리기와 입출력 장치들이 효율적으로 사용될 수 있게 한다.
- 모든 현대 응용체제에서는, 한 응용의 수행이 하나 이상의 프로세스들의 존재에 대응하는 모델에 의존한다.

프로세스에 대한 여러 정의를 정리 하면 다음과 같다.
- 수행 중인 프로그램
- 컴퓨터 상에 수행 중인 프로그램의 인스턴스
- 처리기에 할당되어 수행될 수 있는 개체
- 명령들의 순차 수행, 현재 상태, 연계된 시스템 자원들의 집합 등에 의해 특징지어지는 활성화 단위

&nbsp;&nbsp;&nbsp;&nbsp;프로세스는 수많은 요소들로 구성된 개체로도 생각될 수 있다. 프로세스의 두 필수적인 요소는 프로그램코드 및 코드와 연계된 데이터의 집합이다. 처리기가 프로그램 코드를 수행한다고 가정하면, 그 수행 중인 개체가 프로세스이다.

## 프로세스 제어 블록

&nbsp;&nbsp;&nbsp;&nbsp;프로세스는 식별/제어 되어야 한다. 이러한 정보를 저장하는 자료구조를 프로세스 제어블록(PCB)라 한다. PCB는 운영체제에 의해 생성되어 관리된다.

&nbsp;&nbsp;&nbsp;&nbsp;PCB의 주요 역할은 수행 프로세스를 인터럽트한 후 나중에 그 인터럽트가 발생되지 않은 것처럼 프로세스 수행을 재개할 수 있도록 충분한 정보를 유지하는 것이다. PCB는 운영체제로 하여금 다수의 프로세스를 지원하고 멀티프로세싱을 제공 할 수 있게 해주는 주요 도구이다.

&nbsp;&nbsp;&nbsp;&nbsp;프로세스가 인터럽트될 때, 프로그램 카운터 및 프로세서 레지스터들의 현재 값이 해당 프로세스 제어블록의 적절한 필드에 저장되고, 그 프로세스의 상태가 블록 또는 준비 등과 같은 값으로 변경된다. 이제 운영체제는 어떤 다른 프로세스를 수행 상태로 만들게 되는데, 그 프로세스의 프로그램 카운터와 문맥 데이터를 프로세서 레지스터로 적재하여 그 수행을 시작하게 된다.

## 프로세스 상태

프로그램 수행을 위해 OS는 프로세스를 생성된다.  
프로세서 관점에서 볼 때, 프로세서는 프로그램 카운터 레지스터 값에 의해 결정된 순서에 따라 명령어들을 수행한다.  
개별 프로그램의 관점에서 프로그램의 수행은 자신에 속한 일련의 명령어를 수행한다.

&nbsp;&nbsp;&nbsp;&nbsp;개별 프로세스 행위의 특성은 그 프로세스를 위해 수행되는 일련의 명령어 리스트(프로세스의 궤적-trace)로 표현될 수 있다. 프로세서 행위 특징은 다양한 프로세스들의 궤적이 어떻게 인터리빙 되는지 파악하면 된다.

&nbsp;&nbsp;&nbsp;&nbsp;세 개의 프로세스가 메모리 내에 배치되어있다 가정하자. 설명을 간단히 하기 위해 가상 메모리는 사용되지 않는다. 따라서 세 프로세스는 모두 주기억장치에 완전히 적재된 프로그램으로 표현될 수 있다. 이와 함께 한 프로세스로부터 다른 프로세스로 Switching 하는 작은 Dispatcher 프로그램이 있다.

![](../.src/os1.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;아래 그림은 세 프로세스 수행 초기에 생성된 trace를 보여주고 있다. 프로세스 A와 C의 경우에는 수행된 처음 12개의 명령어들이 수록 되어 있다. 프로세스 B의 경우 네 개의 명령어를 수행하는데, 네 번째 명령어가 입출력 연산을 요청하므로, B는 입출력 완료를 대기해야 한다고 가정하자.

![](../.src/os2.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;이러한 궤적을 처리기 관점에서 살펴보자. 처음 52개 명령어 사이클의 수행 결과로 생성된 번갈아 수행된 궤적을 보여주고 있다. 그림에서 음영으로 어둡게 처리된 부분은 디스패처에 의해 실행된 코드를 나타낸다.

![](../.src/os3.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;각 경우마다 디스패처의 동일 함수들이 실행되므로, 동일 순차의 명령어들이 디스패처에 의해 실행된다. 운영체제는 한 프로세스가 최대 여섯 명령어 사이클 동안만 연속 수행되게 하며, 그 이후 그 프로세스를 인터럽트 한다고 가정한다. 이것은 임의의 한 프로세스가 프로세서 시간을 독점하는 것을 방지한다. Fig 3.4에서 볼 수 있는 바와 같이, 프로세스 A의 처음 여섯 명령어가 수행되어 Time-out(시간 만료) 되면, 프로세스 B로 제어를 넘기기 위해 디스패처 내의 코드(음영처리 된 부분)가 실행된다. 이후, 프로세스 B는 네 개의 명령어를 수행한 후, 입출력을 요청하고 완료되기를 기다리게 된다. 프로세스 B의 수행이 중지되고, 디스패처를 통해 프로세스 C로 제어가 이동된다. C가 Time-out되면, 처리기는 다시 프로세스 A로 이동한다. 프로세스 A가 Time-out될 때, 프로세스 B는 여전히 입출력 연산이 완료되기를 기다리고 있으므로, 디스패처는 프로세스 C로 이동한다.

### A Two-State 프로세스 모델

&nbsp;&nbsp;&nbsp;&nbsp;운영체제의 주요 업무는 프로세스의 수행을 제어하는 것이다. 여기에는 프로세스의 수행을 인터리빙하는 패턴을 결정하는 일과 자원을 프로세스에게 할당하는 일이 포함된다. 프로세스 제어를 위한 운영체제 설계의 첫 단계는 프로세스가 보여 주어야 할 행태를 기술하는 것이다.

&nbsp;&nbsp;&nbsp;&nbsp;어떤 주어진 시점에, 하나의 프로세스는 수행 중이거나 그렇지 않다는 관찰을 통해 가장 간단하면서도 현실성 있는 모델을 구성할 수 있다.

![](../.src/os4.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;위 그림처럼 두 가지 상태, 즉 'Running' 또는 'Not Running' 중의 한 상태에 있게 된다. 운영체제는 새로운 프로세스를 생성할 때, 그 프로세스에 대한 PCB를 생성하고 그 프로세스를 시스템 내에 Not Running 상태로 초기화 시킨다. 이제 프로세스는 존재하게 되며 운영체제에 알려져, 자신이 수행될 기회를 기다린다. 때때로ㅗ, 현재 수행 중인 프로세스가 인터럽트 당하게 되며, 운영체제의 디스패처가 수행할 새로운 프로세스를 선택한다. 인터럽트 당한 프로세스는 Running에서 Not Running으로 상태가 전이되며, 다른 프로세스들 중 하나가 Running 상태로 바뀐다.

&nbsp;&nbsp;&nbsp;&nbsp;각 프로세스는 운영체제가 자신의 상태를 추적할 수 있도록 어떤 식으로든 표현되어야 한다. 즉, 프로세스의 현재 상태와 메모리 내에서의 위치 등 여러 가지 포함한 정보가 필요한데, PCB가 바로 그것이다. 현재 수행되지 않는 프로세스들은 일종의 큐에 저장된 상태로 수행될 차례를 기다린다.

![](../.src/os5.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;위 그림에 있는 단일 큐의 각 항목은 특정 프로세스의 PCB를 가리키는 포인터이다. 다른 대안으로 큐를 데이터 블록들로 이루어진 연결 리스트로 구성할 수도 있는데, 각 블록은 프로세스를 나타낸다.

&nbsp;&nbsp;&nbsp;&nbsp;이 큐잉 다이어그램을 이용하여 디스패처가 동작하는 방식을 설명할 수 있다. 수행 중에 인터럽트 당한 프로세스는 대기 프로세스들의 큐로 옮겨진다. 그러나 만일 프로세스의 수행이 완료되었거나 도중에 취소 되었다면, 프로세스는 폐기(discard)되어 시스템을 떠난다. 어떤 경우든 디스패처는 다음에 수행할 프로세스를 큐에서 선택한다.

### 프로세스 생성과 종료

#### 프로세스 생성

&nbsp;&nbsp;&nbsp;&nbsp;현재 관리되고 있는 프로세스 집단에 새로운 프로세스를 추가하고자 할 때, 운영체제는 그 프로세스를 관리하기 위해 필요한 자료구조를 만들고, 그 프로세스에게 주기억장치 내의 주소공간을 할당한다. 이러한 일련의 작업은 프로세스의 생성을 위해 필요하다.  
&nbsp;&nbsp;&nbsp;&nbsp;일반적으로 네 가지 사건이 발생했을 때 프로세스가 생성된다.
* 새로운 일괄처리 작업  
테이프나 디스크를 통해 운영체제에서 일괄처리 작업 제어 스트림이 제공된다. 운영체제가 새로운 작업을 처리할 준비가 되면, 다음에 수행할 일련의 작업제어 명령을 읽어 들일 것이다.

* 대화형 로그온  
사용자가 터미널에서 시스템에 로그온한다.

* 서비스를 제공하기 위해 OS가 생성  
사용자가 대기할 필요 없도록, 운영체제는 사용자 프로그램을 대신해 어떤 기능을 수행할 프로세스를 생성할 수 있다.

* 기존 프로세스에 의한 생성(spawning)  
모듈화를 위해서나 병렬성을 활용하기 위해, 사용자 프로그램은 많은 프로세스의 생성을 명령할 수 있다.

&nbsp;&nbsp;&nbsp;&nbsp;전통적으로 운영체제는 사용자 또는 응용 프로그램에게 투명하게 모든 프로세스를 생성하였는데, 이러한 방식은 현대 운영체제에서도 일반적으로 사용된다. 그러나 하나의 프로세스가 다른 프로세스를 생성하도록 허용하는 것은 매우 유용할 것이다. 예로 한 응용 프로세스가 자신이 생산하는 데이터를 받아 나중에 분석하기 적합한 형태로 구성하는 다른 프로세스를 생성할 수 있다. 생성된 새로운 프로세스는 그 응용과 병행 수행되며, 처리할 데이터가 생산될 때마다 활성화된다. 이러한 방식은 응용을 구조화하는 데 있어 매우 유용하다. 또 다른 예로, 서버프로세스가 처리해야 할 각각의 요청에 대해 새로운 프로세스를 생성하는 것을 들 수 있다. 이와 같이 운영체제가 어떤 프로세스의 명시적 요청에 의해 해로운 프로세스를 생성할 수 있는데, 이것을 프로세스 생성이라 한다.  
&nbsp;&nbsp;&nbsp;&nbsp;하나의 프로세스가 다른 프로세스를 생성할 때, 전자는 부모 프로세스라고 하고, 후자는 자식 프로세스라 한다.

#### 프로세스 종료  
&nbsp;&nbsp;&nbsp;&nbsp;프로세스가 수행 완료를 표시 할 수 있는 수단을 제공 해야한다. 일괄 처리에서 작업의 종료는 halt 명령이나 명시적으로 운영체제 서비스 호출을 수행 함으로써 이루어진다. 중지 명령어는 프로세스가 완료되었다는 사실을 운영체제에게 통보하기 위해 인터럽트를 발생시킨다. 대화식 응용의 경우, 사용자의 행동에 의해 프로세스의 수행 완료가 표시된다. 시분할 시스템에서 특정 사용자 프로세스는 해당 사용자가 로그 오프를 하거나 터미널을 끌 때, Ctrl+c를 입력할때, quitting application. 이러한 모든 행위는 프로세스를 종료시키기 위해 운영체제에게 서비스를 요청하게 된다.  
&nbsp;&nbsp;&nbsp;&nbsp;OS는 종료와 관련된 사건이 발생하면, 그 프로세스에게 할당된 자원을 회수하고, 자원 사용에 관한 정보를 수집한다.

프로세스가 종료되는 전형적인 이유는 다음과 같다.
* 정상 완료
* 시간 한도 초과
* 메모리 부족
* 경계범위 위반
* 보호 오류
* 산술 오류
* 시간 초과
* 입출력 실패
* 무효 명령어
* 특권 명령어
* 데이터 오용
* 오퍼레이터나 운영체제 간섭
* 부모 종료
* 부모 요청

### A Five-State 프로세스 모델

&nbsp;&nbsp;&nbsp;&nbsp;모든 프로세스들이 항상 수행할 준비가 되어 있다면, 큐잉 규칙이 효과적일 것이다. 그 큐는 선입선출 리스트이고,프로세서는 수행 가능한 프로세스를 라운드 로빈 형식으로 처리한다. 그러나 Not Running 상태에 있는 어떤 프로세스들은 수행할 준비가 되어 있지만, 다른 프로세스들은 입출력 연산이 완료되기를 기다리면서 블록되어 있을 수 있다. 따라서 단일 큐를 사용할 때 디스패처는 단순히 큐의 맨 끝에서부터 프로세스를 선택하지 않아야 한다. 대신에, 디스패처는 리스트를 살펴보고 블록되지 않았으면서 zb에 가장 오래 머문 프로세스를 찾아야만 할 것이다.  
&nbsp;&nbsp;&nbsp;&nbsp;이러한 상황을 보다 자연스럽게 처리하기 위해서는 비수행 상태를 준비 상태와 블록 상태로 분할 하는 것이 좋다.  

![](../.src/os6.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;적절한 대책으로, 차후에 그 유용성이 증명될 또 다른 두 가지 상태를 추가하였다.

* Running : 현재 수행중인 프로세스. 단일 프로레서로 이루어진 컴퓨터로 가정했으므로, 임의 시점에 단지 하나의 프로세스만이 수행 상태 일수 있다.

* Ready : 기회가 주어지면 수행될 준비가 되어 있는 프로세스.

* Blocked/Waiting : 입출력 연산 완료 등과 같은 어떤 이벤트가 발생할 때까지 수행될 수 없는 프로세스

* New : 지금 막 생성되었지만, 운영체제에 의해 수행 가능한 프로세스 풀(pool)로의 진입이 아직 허용되지 않은 프로세스. 전형적으로, 새로운 프로세스는 자신의 PCB가 생성되었다 할지라도 승인때까지 주기억장치에 적재되지 않는다.

* Exit : 프로세스 수행이 중지(halt)되거나 어떤 이유로 중단(abort)되었기 때문에 운영체제에 의해 수행가능 프로세스 풀에서 방출된 프로세스

&nbsp;&nbsp;&nbsp;&nbsp;New와 Exit 상태는 프로세스 관리를 위해 유용한 구성이다. 생성 상태는 지금 막 정의된 프로세스에 대응된다. 예를 들어, 만일 새로운 사용자가 시분할 시스템에 로그온을 시도하거나 새로운 일괄처리 작업이 수행을 위해 제출되면, 운영체제는 두 단계로 새 프로세스를 정의할 수 있다. 첫째, 운영체제는 시스템 관리에 필요한 몇가지를 처리한다. 그 프로세스에 식별자를 부여하고, 그 프로세스를 관리하는데 필요한 테이블들이 할당·구축된다. 이 시점에서 프로세스는 New 상태에 있게 된다. 이것은 운영체제가 프로세스 생성에 필요한 조치를 하였으나, 아직 프로세스의 수행에 필요한 조치는 취하지 않았음을 의미한다. 즉, 수행될 프로그램 코드는 주기억장치에 있지 않으며, 그 프로그램과 관련된 데이터를 위한 공간도 할당되지 않았다. New 상태에 있는 동안 프로그램은 보조 기억장치, 전형적으로 디스크 저장장치에 남아 있다.

&nbsp;&nbsp;&nbsp;&nbsp;프로세스는 두 단계를 거쳐서 시스템에서 퇴장한다. 먼저, 프로세스가 원래의 오나료 지점에 도달하거나, 회복 불능 오류로 인해 수행이 중단되거나, 또는 적정 권한을 가진 다른 프로세스가 프로세스의 수행을 중단시키면 그 프로세스는 종료된다. 프로세스가 종료되면 종료 상태가 된다. 이 시점에서 종료된 프로세스는 더 이상 수행될 수는 없지만, 그 작업과 관련된 테이블과 다른 정보들은 운영체제에 의해 잠시 보존된다. 이렇게 함으로써 보조 또는 지원 프로그램이 제공된 어떤 필요한 정보를 가져갈 수 있는 시간을 제공한다.

![](../.src/os7.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;각 프로세스가 여러 상태들 간에 전이하는 과정이 위 사진에 나타나 있다. 5-상태 모델에는 두 개의 큐, 즉 Ready Queue 및 Block Queue를 이용하여 큐잉 규칙을 구현할 수 있는 방식을 제안한다. 시스템이 한 프로세스를 받아들이면, 그 프로세스는 Ready Queue에 놓여진다. 다른 프로세스를 수행할 시간이 되면, 운영체제는 Ready Queue에 있는 프로세스들 중에서 하나를 선택한다. 우선순위 정책을 사용하지 않는다면, 이 큐는 단순히 선입선출 큐이다. 수행 중인 프로세스가 수행 상태를 벗어날 때는, 그 프로세스가 처해진 상황에 따라 종료되거나, Ready Queue 또는 Block Queue에 놓이게 된다. 마지막으로, 어떤 이벤트가 발생되면 Block Queue에서 그 이벤트를 기다리고 잇던 모든 프로세스들이 Ready Queue로 옮겨진다.

&nbsp;&nbsp;&nbsp;&nbsp;후자의 상황은 이벤트가 발생했을 때 운영체제가 Block Queue를 전체적으로 조사하여 해당 이벤트를 기다리고 있떤 프로세스들을 찾아야 한다는 것을 뜻한다. 대형 운영체제에서는 Block Queue에 수백, 수천 개의 프로세스가 있을 수 있다. 따라서 각 이벤트마다 하나의 블록 큐를 두는 것이 더 효율적일 수도 있다. 이 경우 이벤트가 발생하면, 해당 큐에 있는 모든 프로세스들을 Ready로 전이시키면 된다.

&nbsp;&nbsp;&nbsp;&nbsp;마지막 개선안으로 프로세스의 디스패칭이 우선순위 방식에 의한다면, 우선순위 레벨당 하나의 Ready Queue를 두는 것이 편리할 것이다. 그렇게 하면, 제일 오래 기다린 가장 높은 우선순위의 프로세스를 운영체제가 쉽게 결정할 수 있게 된다.

### 보류된(suspended) 프로세스

&nbsp;&nbsp;&nbsp;&nbsp;더 많은 프로세스를 수용하기 위해 주기억장치의 공간을 더 확보할 필요가 있다. 하지만 공간을 확보하려 한다면 비용 문제가 발생할 것이다. 하지만 주기억장치의 가격이 하락하는 속도만큼 프로그램의 메모리 요구량이 증가하고 있다는 문제가 생겨났다. 이에 따란 해결책으로 스와핑이 있다.

#### 스와핑

&nbsp;&nbsp;&nbsp;&nbsp;프로세스의 일부나 전체를 주기억장치에서 디스크로 이동시키는 방법이다. 이때 이동된 프로세스가 존재하는 디스크의 영역을 '스왑영역'이라고 한다. 주기억장치에 있는 프로세스들 중에서 준비 상태에 있는 프로세스가 하나도 없다면, 운영체제는 블록된 프로세스들 중 하나를 디스크로 내보내고 보류 큐(Suspended Queue)에 넣는다. 이 큐에는 주기억장치로부터 잠시 내쫓겨진 또는 보류된 프로세스들이 존재한다. 즉, 보류 상태에 있다. 그 다음, 운영체제는 보류큐에 있는 다른 프로세스를 주기억장치로 들여오거나 새로운 프로세스 요청이 받아들인 후, 새로이 도착한 프로세스를 가지고 수행을 계속한다.

&nbsp;&nbsp;&nbsp;&nbsp;스와핑은 입출력 연산이기 때문에 문제 해결에 도움을 주기는 커녕 문제를 더 악화시킬 수도 있다. 그러나 디스크 입출력은 시스템에서 가장 빠른 입출력 작업이기 때문에 일반적으로 스와핑은 성능을 향상시킬 것이다.

&nbsp;&nbsp;&nbsp;&nbsp;스와핑을 사용하려면, 또 다른 한 상태, 즉 '보류상태'가 프로세스 행위 모델에 추가되어야 한다.

![](../.src/os8.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;주기억장치에 있는 모든 프로세스들이 블록상태라면 운영체제는 한 프로세스를 보류 상태로 만들고 디스크로 전송한다. 이 때, 주기억장치에 생긴 여유 공간은 다른 프로세스를 불러들이는데 사용할 수 있다.

#### 보류의 다른 용도
&nbsp;&nbsp;&nbsp;&nbsp;보류 상태의 프로세스는 주기억장치에 있지 않은 프로세스라는 것이다. 주기억장치에 존재하지 않는 프로세스는 사건을 기다리고 있건 또는 그렇지 않건 간에 즉시 수행될 수 없다.

&nbsp;&nbsp;&nbsp;&nbsp;보류된 프로세스의 개념을 일반화할 수 있는데, 보류 상태의 프로세스는 다음과 같은 특성을 가지고 있다.
* 즉시 수행될 수 없음
* 사건을 기다릴 수도 있고 그렇지 않을 수도 있음(블록된 이유)
* 어떤 행위자(프로세스 자체나 부모 프로세스, 혹은 운영체제)에 의해 보류 상태가 됨
* 행위자가 명시적으로 해체 명령을 내릴 때까지 보류 상태에서 벗어날 수 없다.

#### 프로세스 보류의 이유

- 스와핑 : 주기억장치 공간 확보
- 운영체제의 다른 이유 : 교착상태가 발생한 프로세스 보류
- 대화식 사용자의 요철 : 프로세스 디버깅을 위해
- 타이밍 : 주기적 수행 프로세스들
- 부모 프로세스의 요청

## 프로세스 기술

&nbsp;&nbsp;&nbsp;&nbsp;OS는 컴퓨터 시스템에서 발생하는 사건들을 제어한다. 프로세서에 의해 수행되는 프로세스들을 스케쥴하여 디스패치하고, 프로세스들에게 자원을 할당하며, 사용자 프로세스의 기본적인 서비스 요청에 응답한다.  OS는 프로세스가 사용하는 시스템 자원들을 관리하는 개체라고 생각할 수있다.
* 프로세스-실행 중인 프로그램 관련 사건
* 메모리 관련 사건
* 입출력 관련 사건
* 파일 관련 사건


![](../.src/os10.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;멀티프로그램 환경의 경우, 생성되어 가상메모리에 존재하는 여러 프로세스들이 있을 수 있다. 각 프로세스들은 수행되는 동안 프로세서와 입출력 장치, 주기억장치 등 특정 시스템 자원을 사용할 필요가 있다. 프로세스 P<sub>1</sub>의 경우, 최소한 자신의 일부분은 주기억장치 내에 있으며 두 개의 입출력 장치에 대한 제어권을 가지고 수행되고 있다. 프로세스 P<sub>2</sub> 또한 주기억장치에 존재한다. 하지만 P<sub>1</sub>에게 할당된 입출력 장치를 얻기 위해 기다리면서 블록되어 있다. 프로세스 P<sub>n</sub>은 주기억장치로부터 스왑아웃 되었고, 따라서 보류 상태에 있다.

### 운영체제 제어 구조
&nbsp;&nbsp;&nbsp;&nbsp;OS가 프로세스와 자원들을 관리하기 위해서는 이들 각가에 대한 현재 상태를 나타내는 정보를 가지고 있어야만 한다. 이러한 정보를 제공하기 위한 일반적인 방법은 간단하다. 즉, 관리하고자 하는 각 개체에 대한 정보를 테이블로 구성해서 유지하는 것이다. 이에 대한 일반적인 개념이 아래 그림에 나타나 있는데, 그림에서 OS가 관리해야 할 서로 다른 4가지 타입(메모리, 입출력 장치, 파일, 프로세스)의 테이블을 볼 수 있다.

![](../.src/os11.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;메모리 테이블은 주기억장치와 보조기억장치 모두 자취를 유지하기 위해 사용된다. 주기억장치의 일부는 운영체제가 사용하도록 예약되어 있고, 나머지는 프로세스들이 사용할 수 있다. 프로세스들은 가상메모리나 간단한 스와핑 기법을 사용하여 보조기억장치 내에 유지되기도 한다.
* 프로세스에게 할당된 주기억장치

* 프로세스에게 할당된 보조 기억장치

* 어떤 프로세스가 특정 공유 메모리 영역에 접근이 가능하다는 속성 등과 같은, 주기억장치 또는 가상메모리 블록에 대한 보호 속성

* 가상 메모리를 관리하기 위해 필요한 정보

&nbsp;&nbsp;&nbsp;&nbsp;입출력 테이블은 입출력 장치와 컴퓨터 시스템의 채널들을 관리하기 위해 운영체제에서 사용된다. 어떤 시점에, 입출력 장치는 이용 가능하거나 특정 프로세스에 할당되어 있다. 입출력 동작이 진행 중일 때, 운영체제는 입출력 동작의 진행 상태와 입출력 전송의 출발지와 목적지로서 사용되는 주기억장치 내의 위치를 알아야만 한다.

&nbsp;&nbsp;&nbsp;&nbsp;파일 테이블에는 파일 존재 여부와 보조기억장치에 저장된 파일의 위치, 현재 상태, 그 밖에 다른 속성들에 대한 정보가 저장된다. 이러한 정보들 대부분은 파일 관리 시스템에 의해 유지되고 사용될 수 잇으며, 그러한 경우 운영체제는 파일에 대한 정보를 극히 일부만 유지하거나 전혀 유지하지 않는다. 어떤 운영체제는 파일 관리에 대한 자세한 사항들을 운영체제 자신이 관리한다.

&nbsp;&nbsp;&nbsp;&nbsp;프로세스 테이블은 프로세스 관리를 위해 사용된다. 이 전에 알아야 할 것이 두 가지 있다. 메모리ㆍ입출력ㆍ파일ㆍ프로세스, 4 개의 테이블은 서로 분리되어 있는 것처럼 보이지만, 이 테이블들은 어떤 식으로든 연결되거나 상호 참조 되어야 한다. 메모리와 입출력 장치, 파일들은 모두 프로세스를 위해 관리되기 때문에, 프로세스 테이블에서 이들 자원에 대한 참조가 직접 또는 간접적으로 이루어져야 한다. 파일 테이블을 통해 참조되는 파일들은 입출력 장치를 경유하여 접근될 수 있고 어떤 경우에는 주기억장치나 가상메모리 내에 존재할 것이다. 이러한 테이블들은 운영체제에 의해 접근 될 수 있어야 하므로 메모리 관리에 종속적이다.  
&nbsp;&nbsp;&nbsp;&nbsp;이 구조는 메모리 관리 기법에 따라 가변적과 일정크기, 두 가지로 나뉜다.

![](../.src/os12.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;운영체제가 처음에 이러한 테이블들을 생성할지를 어떻게 알고 있는 가이다. 명백히 운영체제는 주기억장치가 얼마나 있는지, 입출력 장치는 어떤 것들이 있고 어떻게 식별할 수 있는지 등과 같은 기본 호나경에 대한 정보는 가지고 있어야 한다. 이것은 구성과 관련된 문제다. 즉 운영체제가 초기화될 때, 기본 환경을 정의하고 있는 몇 가지 환경 구성 데이터에 접근할 수 있어야 하며, 이러한 데이터는 사람이나 자동구성 소프트웨어에 의해 운영체제 외부에 생성되어야 한다.

### 프로세스 제어 구조

&nbsp;&nbsp;&nbsp;&nbsp;OS가 프로세스 관리/제어를 하기 위해서는 프로세스가 어느 곳에 위치하고 있는지, 프로세스를 관리에 필요한 속성들에 대해 반드시 알아야 한다.

#### 프로세스 위치

&nbsp;&nbsp;&nbsp;&nbsp;프로세스가 어디에 위치하고 있고 그것의 속성들에 대해 알기 전에 "프로세스는 물리적으로 어떻게 표현되는가?"라는 것을 먼저 얼아야 한다.
* 하나 이상의 프로그램 코드 - 하나의 프로그램 또는 여러 프로그램 집합

* 프로그램과 관련된 전역 또는 지역 변수들

* 미리 정의된 상수

* 프로그램 수행 시 프로시저 호출들의 트랙과 프로시저들 간에 전달되는 매개변수 - 스택

* 프로세서 제어를 위한 속성 - PCB

&nbsp;&nbsp;&nbsp;&nbsp;위의 네 가지 요소, 즉 프로그램과 데이터, 스택, 속성들의 집함을 프로세스 이미지라고 한다.

1. 사용자 데이터
  * 사용자가 공간에서 수정 가능한 부분


2. 사용자 프로그램
  * 수행될 코드


3. 스택
  * 프로시저 호출에 필요한 지역 및 매개변수와 복귀주소


4. 프로세스 제어 블록(PCB)
  * 프로세스를 제어하기 위해 OS가 필요한 데이터

&nbsp;&nbsp;&nbsp;&nbsp;사용자 데이터, 사용자 프로그램, 스택 이 세 개를 묶어 사용자 공간에 존재하며, PCB는 커널 공간에 존재한다. 프로세스 이미지를 도식화 해보면 아래의 그림과 같다.

![](../.src/os13.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;프로세스 이미지의 위치는 프로세스 테이블에 의해 관리되고, 어떤 메모리 관리 기법이 사용되는가에 따라서 달라진다. 연속 메모리 할당이냐 비연속 메모리 할당 두 가지 경우로 나뉜다.

#### 프로세스 속성

&nbsp;&nbsp;&nbsp;&nbsp;프로세스 제어블록에 있는 정보들은 다음과 같은 세 가지의 범주로 나눌 수 있다.

* 프로세스 식별

* 프로세스 상태 정보

* 프로세스 제어 정보

&nbsp;&nbsp;&nbsp;&nbsp;프로세스 식별과 관련해서, 사실상 모든 운영체제는 각 프로세스에게 유일한 식별자를 할당한다. 이 식별자는 단순히 주 프로세스 테이블에 대한 인덱스이다. 이렇게 하지 않으려면, 운영체제가 프로세스 식별자에 기초해서 해당 프로세스 테이블의 위치를 파악할 수 있도록 사상시켜 주는 기법이 있어야 한다. 식별자는 여러가지로 유용하다. 운영체제가 제어하는 많은 다른 테이블들도 프로세스 테이블들을 상호 참조하기 위해 프로세스 식별자를 사용한다. 예를 들어, 주기억장치의 각 영역에 어느 프로세스가 할당되었는지를 알려주는 주기억장치 맵을 제공할 수 있도록 메모리 테이블을 구성할 수도 있다. 이와 같은 참조가 입출력 및 파일 테이블에서도 나타난다. 프로세스들이 서로 통신할 때, 통신할 상대방을 운영체제에게 알려주기 위해 프로세스 식별자를 사용할 수도 있다.  
&nbsp;&nbsp;&nbsp;&nbsp;프로세스 식별자와 더불어, 작업에 대해 책임지고 있는 사용자를 지시하기 위해 사용자 식별자가 각 프로세스에 할당될 수 있다.

&nbsp;&nbsp;&nbsp;&nbsp;프로세서 상태 정보는 프로세서 레지스터의 내용들로 구성된다. 물론, 프로세스가 수행되는 동안에는 그 정보들이 레지스터에 있다. 프로세스가 인터럽트 되어서 중단되면 모든 레지스터 정보들은 저장되어야 한느데, 그 이유는 그 프로세스의 수행이 재개될 때 다시 정보를 복구하기 위해서이다. 여기에 연관된 레지스터의 수나 종류는 프로세서 설계에 따라 달라진다. 대개, 레지스터 집합에는 사용자 가용 레지스터(어셈블러 프로그래밍으로 접근 가능)와 제어ㆍ상태 레지스터(접근 불가), 스택 포인터 등이 포함된다.  
&nbsp;&nbsp;&nbsp;&nbsp;특히, 모든 처리기를 설계할 때 프로그램 상태 워드(PSW)라고 알려진 레지스터 또는 레지스터 집합이 포함된다. PSW에는 상태 정보가 저장되는데, 대개 조건 코드 및 기타 상태 정보가 저장된다.

![](../.src/os14.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;위 그림은 인텔 x86프로세서의 EFLAGS 레지스터이다. 이 구조는 x86 처리기상에서 동작하는 모든 운영체제에서 사용된다.

&nbsp;&nbsp;&nbsp;&nbsp;프로세스 제어 정보이다. 프로세스 제어 정보는, 운영체제가 활성화된 여러 프로세스들을 제어하고 조정하기 위해 필요한 추가 정보이다.
* 스케줄링과 상태 정보
  * 프로세스 상태
  * 우선순위
  * 스케줄링과 관련된 정보
  * 이벤트

* 자료구조화

* 프로세스간 통신(IPC)

* 프로세스 권한

* 메모리 관리

* 자원의 소유권과 이용률

![](../.src/os15.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;위 그림은 가상메모리에서의 프로세스 이미지 구조를 보여주고 있다. 각 프로세스 이미지는 프로세스 제어블록, 사용자 스택, 스포세스의 개별 주소공간, 다른 프로세스들과 공유할 수 있는 어떤 주소공간 등으로 구성된다. 이 그림에서 각 프로세스 이미지의 주소 범위가 연속적인 것처럼 보이지만, 실제 구현에서는 메모리 관리 기법과, 운영체제가 제어 구조를 어떻게 구성하느냐에 따라 달라질 수 있다.

&nbsp;&nbsp;&nbsp;&nbsp;PCB는 구조화 정보(위의 자료구조화)를 포함하고 있는데, 이는 PCB들을 서로 연결하는데 사용되는 포인터를 포함한다. 따라서 앞 절에서 설명된 큐는 PCB들의 연결 리스트로 구현될 수 있다.

<img src="../.src/os16.jpg" width="49%">
<img src="../.src/os17.jpg" width="49%">

#### PCB의 역할

&nbsp;&nbsp;&nbsp;&nbsp;PCB은 운영체제에서 가장 중요한 자료구조이다. 각 PCB에는 운영체제에게 필요한 프로세스의 모든 정보들이 들어 있다. 이 블록들은 스케줄링, 자원 할당, 인터럽트 처리, 성능 측정과 분석 등에 관련된 모듈들을 포함하여 운영체제의 모든 모듈에 의해 읽혀지고 수정될 수 있다. 따라서 PCB의 집합은 운영체제의 상태를 정의한다고 말할 수 있다.
&nbsp;&nbsp;&nbsp;&nbsp;이것은 설계에 있어서 중요한 문제를 발생시킨다. 운영체제 내에 있는 수많은 루틴들은 프로세스 제어블록에 있는 정보들을 접근할 필요가 있다. 이 테이블은 직접 접근할 수 있도록 하는 것은 어렵지 않다. 각 프로세스는 유일한 ID를 가지고 있으므로, 이를 PCB에 대한 포인터 테이블의 색인으로 사용할 수 있다. 문제는 테이블에 대한 접근보다는 보호 쪽에 있으며, 다음과 같은 두 가지 문제가 존재한다.

* 인터럽트 핸들러와 같은 단일 루틴에서의 버그가 프로세스 제어블록에 손상을 줄 수 있고, 결국 해당 프로세스를 관리하는 시스템 기능이 파괴될 수도 있다.

* 프로세스 제어블록의 구조와 의미 부분의 설계가 변경되면 수 많은 운영체제 모듈이 영향받게 될 것이다.

&nbsp;&nbsp;&nbsp;&nbsp;이러한 문제는 운영체제의 모든 루틴들에게 핸들러 루틴을 통하도록 요구함으로써 해결될 수 있다. 핸들러 루틴이 하는 유일한 일은 PCB를 보호하는 것으로, 이 루틴은 제어블록에 대한 읽고 쓰기 연산을 제어하는 유일한 조정자 역할을 한다. 단, 이러한 루틴을 사용하려면 시스템 소프트웨어의 나머지 부분이 올바르다고 신뢰될 수 있는 정도와 성능 이슈를 함께 고려하여 절충해야 한다.

## 프로세스 제어
OS는 사용자 프로그램의 간섭으로부터 주요 자원들을 보호해야 한다는 것이다.

- 응용프로그램과 유틸리티는 "사용자 ISA(Instruction Set Archecture)"에 정의된 명령어 레퍼토리만 사용 - 자원을 핸들링 불가
- OS만 "시스템 ISA"에 정의된 명령어 레퍼토리를 사용 - 자원 핸들링 가능

- 시스템 ISA : 제어 레지스터 접근, 주요 OS 테이블 접근 명령어들로 구성

### 수행모드

&nbsp;&nbsp;&nbsp;&nbsp;대부분의 프로세서는 최소한 두 가지 수행 모드를 지원한다. 어떤 명령어들은 더 높은 권한을 가진 모드에서만 수행된다. 이러한 명령어에는 프로그램 상태 워드와 같은 제어 레지스터의 읽기 또는 변경하기, 기본적인 입출력 명령어, 그리고 메모리 관리에 관련된 명령어 등이 포함된다. 또한, 메모리의 특정 영역은 더 높은 권한을 가진 모드에서만 접근될 수 있다.  

&nbsp;&nbsp;&nbsp;&nbsp;권한을 덜 가진 모드를 보통 사용자 모드라고 하는데, 사용자 프로그램들이 일반적으로 이 모드에서 수행되기 때문이다. 더 높은 권한을 가진 모드는 시스템 모드, 제어 모드, 커널 모드 등으로 불린다. 이 때 프로세서는 자신이 사용자 관련 프로그램을 수행하는가 운영체제 관련 프로그램을 수행하는가 구별이 가능해야 한다.

&nbsp;&nbsp;&nbsp;&nbsp;두 가지 모드를 사용하는 이유는 사용자 프로그램의 간섭으로부터 운영체제 및 PCB와 같은 주요 운영체제 테이블들을 보호할 필요가 있기 때문이다. 커널 모드에서 수행되는 소프트웨어는 처리기와 모든 명령어들, 레지스터들, 그리고 메모리를 완전히 제어할 수 있다. 그러한 제어 수준은 사용자 프로그램의 경우에 필요하지 않으며, 안전을 위해서도 바람직 하지 않다.

&nbsp;&nbsp;&nbsp;&nbsp;수행 모드와 관련하여 두 가지 문제가 발생할 수 있다.

1. 처리기가 현재 어떤 모드에서 수행되고 있는지 어떻게 알 수 있는가?
  * 세그먼트 레지스터를 이용하여 나타냄(IA-32 x86 R플래그)

  * 프로세서 상태 레지스터를 이용하여 나타냄(IA-64 psr)

2. 어떻게 모드는 변경 되는가?
  * 응용프로그램이 OS 서비스 호출(사용자 모드 → 커널 모드)

  * 예외 및 인터럽트 발생(사용자 모드 → 커널 모드)

  * 서비스 호출/인터럽트 핸들링 루틴의 종료(커널 모드 → 사용자 모드)

  * 수행 모드 전환 시에 처리기 문맥이 저장 및 복구 되어야 됨.(문맥 교환)

### 프로세스 생성

&nbsp;&nbsp;&nbsp;&nbsp;OS가 새로운 프로세스를 생성하기로 결정할 경우 아래와 같은 절차로 프로세스가 생성된다.

1. 유일한 프로레스 식별자 할당
  * 새로운 항목이 주요 프로세스 테이블에 추가 된다.


2. 주소 공간 할당
  * 사용자 주소공간, 사용자 스택을 위해 필요한 공간이 어느 정도인지 알아야 한다.


3. PCB 초기화
  * 프로세스 식별 부분에는 해당 프로세스의 ID 및 또 다른 ID, 즉 부모 프로세스의 ID와 같은 정보 포함

  * 프로그램 카운터를 프로그램 진입점으로 초기화

  * 프로세스 스택 경계를 정의하기 위해 시스템 스택 포인터를 초기화

  * 위 항목을 제외하고 대부분의 항목들을 0으로 초기화

4. 적절한 링크 설정
  * 각 스케줄링 큐를 연결 리스트로 유지하고 있다면, 준비 또는 준비/보류 리스트에 놓여져야 한다.


5. 그 외 필요한 자료 구조 생성

### 프로세스 교환

&nbsp;&nbsp;&nbsp;&nbsp;수행 중인 프로세스가 어느 시점에 인터럽트되면, 운영체제는 다른 프로세스를 수행 상태로 바꾸고, 그 프로세스에게 제어를 넘겨 준다.(문맥 교환) 이를 프로세스 교환이라고 한다. 이때 설계시 고려해야할 이슈가 있다.

* 프로세스 교환을 유발시키는 사건들에는 어떤 것들이 있는가?
* 프로세스 교환시 OS 자신이 제어하는 여러 자료구조(PCB 등)들을 어떻게 다룰 것인가?

#### 프로세스 교환 시점

운영체제가 현재 수행 중인 프로세스로부터 제어를 넘겨받을 때마다, 프로세스 교환이 발생한다. 운영체제로 넘어갈 수 잇게 하는 사건은 총 3가지 이다.

* 인터럽트
  * 원인 : 현재 명령어 수행의 외부
  * 비동기적 외부 사건에 반응(비동기적 : 코드 내에서 다른 시간, 다른 장소 ↔ 동기적 : 코드 내에서 같은 시간, 같은 장소)
  * 클럭, 인터럽트, 입출력 인터럽트, 메모리 부재 인터럽트

* 트랩
  * 원인 : 현재 명령어 수행과 관련
  * 불법적인 파일 접근 시도, 수행 중에 발행한 오류 및 예외 상황 (=2/0)
  * 해당 프로세스가 종료될 수도 있음 ← 복구가 불가능한 상황

* 수퍼바이저 호출
  * 선점과 비선점으로 나뉨
  * 원인 : 명시적 요청
  * 파일 개방 등과 같은 OS서비스에 대한 호출

#### 모드 전환

인터럽트 단계에서 처리기는 인터럽트 시그널 존재 여부를 가지고 인터럽트가 발생되었는지를 검사한다. 대기하고 있는 인터럽트가 없다면, 처리기는 반입 단계를 계속 수행하여, 현재 프로세스가 수행시키고 있는 프로그램의 명령어를 가져온다. 대기하고 있는 인터럽트가 있다면, 처리기는 다음과 같은 작업을 수행한다.

* PC의 값을 인터럽트 핸들러 프로그램의 시작 주소로 설정
* 사용자 모드를 커널 모드로 전환시켜서 인터럽트 처리 코드가 특권 명령어를 수행할 수 있도록 한다.

이후 과정은 다음과 같다.

1. 프로세서가 PSW와 PC를 인터럽트된 프로세스의 PCB에 저장
2. 프로세서가 인터럽트 핸들러의 주소를 PC에 적재
3. 그 외 레지스터들의 내용을 인터럽트된 프로세스의 PCB에 저장
4. 커널 모드로 전환
5. 인터럽트 처리
6. 인터럽트된 프로세스의 레지스터들의 내용을 복원
7. PSW와 PC의 내용을 복원

과정 1은 하드웨적 처리를, 과정 2 ~ 과정 7까지는 OS가 SW적 처리하는 과정을 거친다.

#### 프로세스 상태 변경

&nbsp;&nbsp;&nbsp;&nbsp;모드 전환은 프로세스 교환과는 다른 개념이다. 모드 전환은 현재 수행 상태에 있는 프로세스의 상태를 바꾸지 않고 수행될 수 있다. 하지면 현재 수행 상태인 프로세스가 다른 상태로 전이되면, 운영체제는 그 환경을 크게 변경 시켜야한다.

1. PSW, PC 및 다른 레지스터들을 포함하여 프로세서의 문맥을 저장
2. 현재 수행 상태에 있는 프로세스의 PCB를 갱신
3. 이 프로세스의 PCB를 Ready Queue, Block Queue, 또는 Ready/Suspen Queue 중의 하나에 삽입
4. 실행할 다른 프로세스를 선택
5. 새로 선택된 프로세스의 PCB를 갱신
6. 선택된 프로세스의 PCB를 Ready Queue에서 삭제
7. 선택된 프로세스의 문맥을 복원

## 운영체제의 수행

본 책에서 운영체제에 대해 두 가지 흥미로운 점이 있다고 지적하였다.

* 운영체제는 일반적인 컴퓨터 소프트웨어와 같은 방식으로 작동한다. 즉, 운영체제는 처리기에 의해 수행 되는 프로그램의 집합이다.
* 운영체제는 제어를 자주 양도하며, 제어를 다시 획득하기 위해 프로세서에 의존한다.

운영체제가 단지 프로그램들의 집합이고 다른 프로그램들 처럼 프로세서에 의해서 수행된다면,
* 운영체제를 하나의 프로세스로 볼 수 있는가?
* 그렇다면 운영체제를 어떻게 관리해야 하나?

&nbsp;&nbsp;&nbsp;&nbsp;설계 접근 방법
  * 비 프로세스 커널(LINUX)
  * 사용자 프로세스 내에서 수행
  * 분리된 프로세스로 수행(Window)

### 비 프로세스 커널

&nbsp;&nbsp;&nbsp;&nbsp;전통적이고 일반적으로 사용된 방법으로, 모든 프로세스의 외부에서 커널을 수행시키는 것이다. 이 방법에서는 현재 수행 중인 프로세스가 인터럽트 당하거나 슈퍼바이저 호출을 요청할 때, 그 프로세스의 문맥이 저장되고 제어가 커널로 넘어간다. 운영체제는 자신이 사용할 메모리 영영도 갖고, 프로시저 호출과 복귀를 위한 자신의 시스템 스택도 갖는다. 프로세스의 개념은 단지 사용자 프로그램에만 적용 되며, 운영체제 코드는 분리된 개체로서 수행이 되고, 특권모드에서 작동한다.

![](../.src/os18.jpg)

### 사용자 프로세스 내에서 수행

&nbsp;&nbsp;&nbsp;&nbsp;소형 컴퓨터(PC, 워크스테이션)을 위한 OS설계 방법으로 사용자 프로세스 문맥 내에서 OS 기능을 수행한다. 운영체제 프로그램 수행 시 커널 모드로 전환되며, 프로세스 교환이 필요 없고 모드 전환만이 발생한다.

![](../.src/os19.jpg)

### 프로세스 기반 운영체제

&nbsp;&nbsp;&nbsp;&nbsp;OS를 기능별로 여러개의 분리된 프로세스들로 구성한 형태로 커널 부분은 커널 모드에서 수행, 운영체제를 모듈화 할 수 있다. 마지막으로 운영체제를 프로세스의 집합으로 구현하는 것은, 다중 프로세서나 멀티 컴퓨터 환경에서 유용하다.

![](../.src/os20.jpg)
